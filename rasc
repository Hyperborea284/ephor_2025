Temos uma aplicação web django, que roda dentro de um container docker; nesta funciona um mecanismo de blog no qual cada postagem é a ativação de um microsservço flask o qual, em cada ativação, gera ou reativa um container docker com a aplicação flask, sendo que cada um destes possui uma identificação única, associada ao id do container. No presente momento ocorrem erros na ativação dos contnainers flask, feitas através do container django.	

.
├── app.py
├── blog
│   ├── admin.py
│   ├── apps.py
│   ├── forms.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── 0002_flaskinstance.py
│   │   ├── 0003_delete_post.py
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── chrome_extension
│   ├── background.js
│   ├── content.js
│   ├── icon.png
│   ├── manifest.json
│   ├── popup.html
│   └── popup.js
├── db.sqlite3
├── docker-compose.yml
├── Dockerfile-django
├── Dockerfile-flask
├── entrypoint-django.sh
├── entrypoint-flask.sh
├── ephor_2025
│   ├── asgi.py
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── modules
│   ├── base.py
│   ├── db_manager.py
│   ├── dist_normal.py
│   ├── entity_finder.py
│   ├── goose_scraper.py
│   ├── llamas.py
│   ├── prospect.py
│   ├── representacao_social.py
│   ├── sent_bayes.py
│   └── timeline_generator.py
├── output
├── pyvenv.cfg
├── rasc
├── rasc_text
├── requirements_django.txt
├── requirements_flask.txt
├── static
│   ├── css
│   │   ├── app.css
│   │   └── timeline.css
│   ├── dbs
│   │   ├── 20250117_014212.db
│   │   ├── 20250117_020504.db
│   │   ├── 20250117_021223.db
│   │   └── 20250117_021318.db
│   ├── favicon.ico
│   └── js
│       ├── app.js
│       └── timeline.js
├── templates
│   ├── blog
│   │   ├── instance_form.html
│   │   ├── instance_list.html
│   │   └── instance_view.html
│   ├── entities_and_locations.html
│   ├── index.html
│   ├── landing_page.html
│   └── timeline.html
├── test_app.py
└── uwsgi.ini

12 directories, 65 files



Dockerfile_django
# Dockerfile-django
FROM python:latest

# Instalar dependências do sistema
RUN apt-get update && apt-get install -y \
    build-essential \
    default-jdk \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

RUN pip install --upgrade pip

# Copia os requisitos e instala as dependências
COPY requirements_django.txt .
RUN pip install --no-cache-dir -r requirements_django.txt

# Copia o código da aplicação
COPY . .

# Copia o entrypoint e o uwsgi.ini
COPY entrypoint-django.sh /app/entrypoint-django.sh
COPY uwsgi.ini /app/uwsgi.ini

# Torna o entrypoint executável
RUN chmod +x /app/entrypoint-django.sh

# Expõe a porta 8000 (padrão do Django)
EXPOSE 8000

# Comando para rodar o entrypoint
CMD ["/app/entrypoint-django.sh"]


Dockerfile_flask
# Dockerfile-flask
FROM python:latest

WORKDIR /app

RUN python3 install spacy
RUN python -m spacy download pt_core_news_sm
RUN python3 -m spacy download en_core_web_sm

# Copia os requisitos e instala as dependências
COPY requirements_flask.txt .
RUN pip install --no-cache-dir -r requirements_flask.txt

# Copia o código da aplicação
COPY . .

# Copia o entrypoint e o uwsgi.ini
COPY entrypoint-django.sh /app/entrypoint-flask.sh
COPY uwsgi.ini /app/uwsgi.ini

# Torna o entrypoint executável
RUN chmod +x /app/entrypoint-flask.sh

# Expõe a porta 5000 (padrão do Flask)
EXPOSE 5000

# Comando para rodar o uWSGI
CMD ["uwsgi", "--ini", "uwsgi.ini"]


docker-compose.yml
version: '3.8'

services:
  django:
    build:
      context: .
      dockerfile: Dockerfile-django
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    environment:
      - FLASK_SERVICE_URL=http://flask:5000

settings.py
"""
Django settings for ephor_2025 project.

Generated by 'django-admin startproject' using Django 5.1.5.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Defina o diretório para coletar arquivos estáticos
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-man)2xatd%#8fpu*5=m()hy(c$eeqel5qk(=7#n62iz64aer2t'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes', 
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.sites', 
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'blog', 
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'allauth.account.middleware.AccountMiddleware', 
]

ROOT_URLCONF = 'ephor_2025.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')], 
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'ephor_2025.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

SITE_ID = 1


LOGIN_REDIRECT_URL = 'post_list'  # Redireciona para a lista de postagens (blog)
ACCOUNT_LOGOUT_REDIRECT_URL = 'landing_page'  # Página para redirecionar após o logout

blog/models.py
from django.db import models
from django.contrib.auth.models import User

class FlaskInstance(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)  # Usuário que criou a instância
    container_id = models.CharField(max_length=100, blank=True, null=True)  # ID do container Docker
    name = models.CharField(max_length=200)  # Nome da instância
    created_at = models.DateTimeField(auto_now_add=True)  # Data de criação
    updated_at = models.DateTimeField(auto_now=True)  # Data de atualização

    def __str__(self):
        return self.name

blog/views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import FlaskInstance
from .forms import FlaskInstanceForm
import docker

def landing_page(request):
    return render(request, 'landing_page.html')

@login_required
def instance_list(request):
    instances = FlaskInstance.objects.filter(user=request.user)
    return render(request, 'blog/instance_list.html', {'instances': instances})

@login_required
def create_instance(request):
    if request.method == 'POST':
        form = FlaskInstanceForm(request.POST)
        if form.is_valid():
            instance = form.save(commit=False)
            instance.user = request.user
            instance.save()
            messages.success(request, "Instância criada com sucesso!")
            return redirect('instance_list')
    else:
        form = FlaskInstanceForm()
    return render(request, 'blog/instance_form.html', {'form': form})

@login_required
def start_instance(request, pk):
    try:
        client = docker.from_env()
        instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
        if not instance.container_id:
            container = client.containers.run(
                'sua-imagem-flask',  # Nome da imagem Docker da aplicação Flask
                detach=True,  # Executa o container em segundo plano
                name=f"flask-instance-{instance.pk}",  # Nome único para o container
                ports={'5000/tcp': 5000}  # Expõe a porta 5000
            )
            instance.container_id = container.id
            instance.save()
            messages.success(request, "Instância iniciada com sucesso!")
        else:
            messages.warning(request, "A instância já está em execução.")
    except docker.errors.DockerException as e:
        messages.error(request, f"Erro ao iniciar a instância: {e}")
    return redirect('instance_list')

@login_required
def stop_instance(request, pk):
    try:
        client = docker.from_env()
        instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
        if instance.container_id:
            container = client.containers.get(instance.container_id)
            container.stop()
            instance.container_id = None
            instance.save()
            messages.success(request, "Instância parada com sucesso!")
        else:
            messages.warning(request, "A instância já está parada.")
    except docker.errors.DockerException as e:
        messages.error(request, f"Erro ao parar a instância: {e}")
    return redirect('instance_list')

@login_required
def view_instance(request, pk):
    instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
    return render(request, 'blog/instance_view.html', {'instance': instance})

blog/apps.py
from django.apps import AppConfig

class BlogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'blog'

blog/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.instance_list, name='instance_list'),  # Lista de instâncias
    path('create/', views.create_instance, name='create_instance'),  # Criar instância
    path('start/<int:pk>/', views.start_instance, name='start_instance'),  # Iniciar instância
    path('stop/<int:pk>/', views.stop_instance, name='stop_instance'),  # Parar instância
    path('view/<int:pk>/', views.view_instance, name='view_instance'),  # Visualizar instância
]

urls.py
from django.contrib import admin
from django.urls import path, include
from blog.views import landing_page  # Importe a view do aplicativo blog

urlpatterns = [
    path('', landing_page, name='landing_page'),  # Landing page na raiz
    path('admin/', admin.site.urls),
    path('accounts/', include('allauth.urls')),  # URLs do django-allauth
    path('blog/', include('blog.urls')),  # URLs da aplicação blog
]


A view deve inciar um container flask e renderizá-lo no contexto do blog django, como um microsserviço,
cada microsserviço destes deve ficar disponível para o usuário reativá-lo num mecanismo de blog, onde cada postagem, não é um forms de texto, onde cada postagem é uma ativação deste microsserviço.



além desse erro:


base@hermes:~/Nextcloud/Desktop/scraper_2025$ sudo su
[sudo] senha para base: 
root@hermes:/home/base/Nextcloud/Desktop/scraper_2025# docker-compose up
Starting scraper_2025_django_1 ... done
Attaching to scraper_2025_django_1
django_1  | Criando superusuário...
django_1  | CommandError: Error: That username is already taken.
django_1  | Superusuário já existe ou erro ao criar.
django_1  | Executando makemigrations...
django_1  | No changes detected
django_1  | Executando migrate...
django_1  | Operations to perform:
django_1  |   Apply all migrations: account, admin, auth, blog, contenttypes, sessions, sites, socialaccount
django_1  | Running migrations:
django_1  |   No migrations to apply.
django_1  | Coletando arquivos estáticos...
django_1  | 
django_1  | 0 static files copied to '/app/static', 125 unmodified.
django_1  | Iniciando Django com uWSGI...
django_1  | [uWSGI] getting INI configuration from /app/uwsgi.ini
django_1  | *** Starting uWSGI 2.0.28 (64bit) on [Sat Jan 18 19:32:01 2025] ***
django_1  | compiled with version: 12.2.0 on 18 January 2025 19:21:26
django_1  | os: Linux-6.8.0-50-lowlatency #51.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 21 12:44:17 UTC 2024
django_1  | nodename: 842bca1a5127
django_1  | machine: x86_64
django_1  | clock source: unix
django_1  | pcre jit disabled
django_1  | detected number of CPU cores: 16
django_1  | current working directory: /app
django_1  | detected binary path: /usr/local/bin/uwsgi
django_1  | uWSGI running as root, you can use --uid/--gid/--chroot options
django_1  | *** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** 
django_1  | chdir() to /app
django_1  | your memory page size is 4096 bytes
django_1  | detected max file descriptor number: 1048576
django_1  | lock engine: pthread robust mutexes
django_1  | thunder lock: disabled (you can enable it with --thunder-lock)
django_1  | uWSGI http bound on :8000 fd 4
django_1  | uwsgi socket 0 bound to TCP address 127.0.0.1:37569 (port auto-assigned) fd 3
django_1  | uWSGI running as root, you can use --uid/--gid/--chroot options
django_1  | *** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** 
django_1  | Python version: 3.13.1 (main, Jan 14 2025, 05:25:12) [GCC 12.2.0]
django_1  | Python main interpreter initialized at 0x7cbc67da3a70
django_1  | uWSGI running as root, you can use --uid/--gid/--chroot options
django_1  | *** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** 
django_1  | python threads support enabled
django_1  | your server socket listen backlog is limited to 100 connections
django_1  | your mercy for graceful operations on workers is 60 seconds
django_1  | mapped 416880 bytes (407 KB) for 8 cores
django_1  | *** Operational MODE: preforking+threaded ***
django_1  | WSGI app 0 (mountpoint='') ready in 0 seconds on interpreter 0x7cbc67da3a70 pid: 11 (default app)
django_1  | uWSGI running as root, you can use --uid/--gid/--chroot options
django_1  | *** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** 
django_1  | *** uWSGI is running in multiple interpreter mode ***
django_1  | spawned uWSGI master process (pid: 11)
django_1  | spawned uWSGI worker 1 (pid: 12, cores: 2)
django_1  | spawned uWSGI worker 2 (pid: 14, cores: 2)
django_1  | spawned uWSGI worker 3 (pid: 16, cores: 2)
django_1  | spawned uWSGI worker 4 (pid: 18, cores: 2)
django_1  | spawned uWSGI http 1 (pid: 20)
django_1  | [pid: 16|app: 0|req: 1/1] 172.28.0.1 () {54 vars in 1282 bytes} [Sat Jan 18 19:36:45 2025] GET /blog/view/1/ => generated 470 bytes in 278 msecs (HTTP/1.1 200) 7 headers in 221 bytes (1 switches on core 0)
django_1  | Not Found: /static/css/app.css
django_1  | [pid: 16|app: 0|req: 2/2] 172.28.0.1 () {50 vars in 1189 bytes} [Sat Jan 18 19:36:46 2025] GET /static/css/app.css => generated 2470 bytes in 15 msecs (HTTP/1.1 404) 6 headers in 215 bytes (1 switches on core 1)
django_1  | [pid: 16|app: 0|req: 3/3] 172.28.0.1 () {54 vars in 1289 bytes} [Sat Jan 18 19:36:47 2025] GET /blog/stop/1/ => generated 0 bytes in 6 msecs (HTTP/1.1 302) 9 headers in 668 bytes (1 switches on core 0)
django_1  | [pid: 16|app: 0|req: 4/4] 172.28.0.1 () {54 vars in 1280 bytes} [Sat Jan 18 19:36:47 2025] GET /blog/ => generated 706 bytes in 7 msecs (HTTP/1.1 200) 7 headers in 221 bytes (1 switches on core 1)
django_1  | Not Found: /static/css/app.css
django_1  | [pid: 18|app: 0|req: 1/5] 172.28.0.1 () {50 vars in 1187 bytes} [Sat Jan 18 19:36:48 2025] GET /static/css/app.css => generated 2470 bytes in 228 msecs (HTTP/1.1 404) 6 headers in 215 bytes (1 switches on core 0)
django_1  | [pid: 18|app: 0|req: 2/6] 172.28.0.1 () {54 vars in 1289 bytes} [Sat Jan 18 19:36:49 2025] GET /blog/start/1/ => generated 0 bytes in 27 msecs (HTTP/1.1 302) 9 headers in 671 bytes (1 switches on core 1)
django_1  | [pid: 16|app: 0|req: 5/7] 172.28.0.1 () {54 vars in 1276 bytes} [Sat Jan 18 19:36:49 2025] GET /blog/ => generated 706 bytes in 6 msecs (HTTP/1.1 200) 7 headers in 221 bytes (1 switches on core 0)
django_1  | Not Found: /static/css/app.css
django_1  | [pid: 14|app: 0|req: 1/8] 172.28.0.1 () {50 vars in 1190 bytes} [Sat Jan 18 19:36:49 2025] GET /static/css/app.css => generated 2470 bytes in 242 msecs (HTTP/1.1 404) 6 headers in 215 bytes (1 switches on core 0)
django_1  | [pid: 16|app: 0|req: 6/9] 172.28.0.1 () {54 vars in 1290 bytes} [Sat Jan 18 19:36:51 2025] GET /blog/view/1/ => generated 470 bytes in 5 msecs (HTTP/1.1 200) 7 headers in 221 bytes (1 switches on core 1)
django_1  | Not Found: /static/css/app.css
django_1  | [pid: 12|app: 0|req: 1/10] 172.28.0.1 () {50 vars in 1197 bytes} [Sat Jan 18 19:36:52 2025] GET /static/css/app.css => generated 2470 bytes in 257 msecs (HTTP/1.1 404) 6 headers in 215 bytes (1 switches on core 0)

