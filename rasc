Considere uma aplicação django a qual precisa ativar microsserviços flask em cada uma das ativações de uma instância, e deverá entregar o conteúdo deste para a visualização; este microsserviço flask rodará dentro de um container docker, ao mesmo tempo, a aplicação django já roda num container docker e é servida via ngix e uwsgi, e outros containers flask deverão ser iniciados na criação/destruição/reativação de cada instância flask e serão servidos pelo django; no contexto atual o django espera em localhost:5000 o conteúdo do container flask; cada container flask deve ter uma identificação única somando o nome dadopelo usuário e uma string aleatória única; partindo daqui, depure e indique onde buscar mais informações sobre esta integração.

forms.py
from django import forms
from .models import FlaskInstance

class FlaskInstanceForm(forms.ModelForm):
    class Meta:
        model = FlaskInstance
        fields = ['name']  # Campos editáveis pelo usuário

views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import FlaskInstance
from .forms import FlaskInstanceForm
import docker

def landing_page(request):
    return render(request, 'landing_page.html')

@login_required
def instance_list(request):
    instances = FlaskInstance.objects.filter(user=request.user)
    return render(request, 'blog/instance_list.html', {'instances': instances})

@login_required
def create_instance(request):
    if request.method == 'POST':
        form = FlaskInstanceForm(request.POST)
        if form.is_valid():
            instance = form.save(commit=False)
            instance.user = request.user
            instance.save()
            messages.success(request, "Instância criada com sucesso!")
            return redirect('instance_list')
    else:
        form = FlaskInstanceForm()
    return render(request, 'blog/instance_form.html', {'form': form})

@login_required
def start_instance(request, pk):
    try:
        client = docker.from_env()
        instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
        if not instance.container_id:
            container = client.containers.run(
                'sua-imagem-flask',  # Nome da imagem Docker da aplicação Flask
                detach=True,  # Executa o container em segundo plano
                name=f"flask-instance-{instance.pk}",  # Nome único para o container
                ports={'5000/tcp': 5000}  # Expõe a porta 5000
            )
            instance.container_id = container.id
            instance.save()
            messages.success(request, "Instância iniciada com sucesso!")
        else:
            messages.warning(request, "A instância já está em execução.")
    except docker.errors.DockerException as e:
        messages.error(request, f"Erro ao iniciar a instância: {e}")
    return redirect('instance_list')

@login_required
def stop_instance(request, pk):
    try:
        client = docker.from_env()
        instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
        if instance.container_id:
            container = client.containers.get(instance.container_id)
            container.stop()
            instance.container_id = None
            instance.save()
            messages.success(request, "Instância parada com sucesso!")
        else:
            messages.warning(request, "A instância já está parada.")
    except docker.errors.DockerException as e:
        messages.error(request, f"Erro ao parar a instância: {e}")
    return redirect('instance_list')

@login_required
def view_instance(request, pk):
    instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
    return render(request, 'blog/instance_view.html', {'instance': instance})

models.py
from django.db import models
from django.contrib.auth.models import User

class FlaskInstance(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)  # Usuário que criou a instância
    container_id = models.CharField(max_length=100, blank=True, null=True)  # ID do container Docker
    name = models.CharField(max_length=200)  # Nome da instância
    created_at = models.DateTimeField(auto_now_add=True)  # Data de criação
    updated_at = models.DateTimeField(auto_now=True)  # Data de atualização

    def __str__(self):
        return self.name