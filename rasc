Partindo destes codigos, esta aplicaçao web a qual realiza diversas análises em um corpus de texto; esta possui quatro abas, cada uma associada à um mecanismo de análise de conteúdos (Entidades e Localidades, Geração de timeline, Análise de sentimentos e Representações Sociais), sendo estes textos inseridos na aplicação por três mecanismos (Texto copiado, texto raspado de links e arquivo txt), os quais pode montar um corpus unificado de texto; estas funcionalidades não devem ser removidas, alteradas, omitidas, sendo preservadas à todo custo, de maneira cumulativa e convergente.

Preserve ipsis litteris as partes não afetadas diretamente pelas alterações, não desidrate, remova, retire, omita trechos e funcionalidades, garanta a incorporaçao cumulativa e convergente das alteraçoes propostas.

Esta ativação do arquivo entity_finder.py, visa a identificação das entidades. Nesta aba, "Entidades e Localidades" haverá um botão o qual acionará o respectivo backend, sendo este responsável pela identificação de entidades, pessoas e localidades, neste corpus de texto definido pelo mecanismo de ingestão anterior, seja qual mecanismo de ingestão de conteúdo que for, único ou compartillhado. Esta ativação funcionará gerando uma visualização das informações, apresentada na aba de entidades e localizações:

a) Principais tópicos
b) Resumo
c) Pessoas + imagens respectivas
d) Entidades + imagens respectivas
e) Mapa contendo as Localidades + imagens respectivas

Sobre as entidades: Deve haver um fallback para colocar um mecanismo de colocar um placeholder para as imagens não disponibilizadas pela serpApi, visto que as ativações anteriores já esgotaram a quantidade de chamados neste mês, mas sabemos que a implementação apresentada funciona. Apenas verifique se existe alguma duplicação nest ativação, caso exista duplicação, sintetize tudo num chamado apenas.

Para montar este mapa use:

import folium
from geopy.geocoders import Nominatim
from geopy.exc import GeocoderTimedOut, GeocoderServiceError

De maneira a garantir que este será gerado dinâmicamente com os dados de licalização obtidos pela ativação acima, associada à ativação das apis.
Este mapa têm de ser dinâmicamente gerado e não pode ter informações hard-coded,  para tanto, as funcionalidades do html mapa, devem ser fundidas no html entities_and_location.html, de maneira à descartar o uso do arquivo mapa.html, deste, deve-se aproveitar a estética e os elementos visuais.

Estas informações a/b/c/d/e/ deverão ser compartilhadas no objeto 'shared_content' com as outras aplicações, para fins de contexto ativados em alterações posteriores.

Para tanto, altere o mecanismo de identificação das entidades para se assegurar que:

1) A ativação do arquivo entity_finder.py se dê quando ocorrer a ativação do botão 'Identificar entidades'; no presente momento a ativação deste se dá quando a aba é clicada, tal funcionalidade deve ser removida

2) Importantíssimo: A aba "Geração de Timeline" já apresenta uma lista das timelines geradas e um botão para a geração de uma nova timeline, com os dados do corpus de texto carregado, estas funcionalidades devem ser preservadas. Além disso, a visualização das timelines, quando estas são selecionadas ou geradas, através da renderização específica envolvendo timeline.js, timeline.html e o arquivo xml selecionado, deve ser reimplementada. As funcionalidades para tanto já constam nos respectivos arquivos. Esta funcionalidade foi perdida em uma alteração anterior e precisa ser recomposta. Todos os elementos estilísticos, estéticos, linhas verticais, linhas de data horizontal e no topo, caixa indicando as categorias, sobreposições usadas na composição da linha do tempo devem ser perservados. Fora deste html dinâmicamente gerado, o botão 'Gerar Timeline' e o meu dropdown 'Timelines disponíveis' devem estar no mesmo alinhamento que os botões nas outras abas.

Garanta a aplicação convergente e cumulativa dos elementos estétitcos, funcionais e estilisticos do projeto original.

Preserve todas as caracteristicas, de maneira cumulativa e convergente. Preserve ipsis litteris as partes na afetadas diretamente pela alteraçao, nao desidrate, remova, retire, omita trechos e funcionalidades, garanta a incorporaçao cumulativa e convergente das alteraçoes. Apresente a versão completa e corrigida dos códigos convergentes, contendo as alterações cumulativas.


├── app.py
├── chrome_extension
│   ├── background.js
│   ├── content.js
│   ├── icon.png
│   ├── manifest.json
│   ├── popup.html
│   └── popup.js
├── links_teste.txt
├── modules
│   ├── base.py
│   ├── dist_normal.py
│   ├── entity_finder.py
│   ├── goose_scraper.py
│   ├── representacao_social.py
│   ├── sent_bayes.py
│   └── timeline_generator.py
├── output
├── rasc.py
├── requirements.txt
├── static
│   ├── css
│   │   ├── app.css
│   │   └── timeline.css
│   ├── favicon.ico
│   ├── generated 
│   │   ├── timeline_output
│   └── js
│       ├── app.js
│       └── timeline.js
├── templates
│   ├── entities.html
│   ├── index.html
│   ├── mapa.html
│   └── timeline.html
└── timeline.xml

app.py
from flask import Flask, request, render_template, jsonify
import pandas as pd
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import os
import time
import sys
from dotenv import load_dotenv

from modules.sent_bayes import SentimentAnalyzer
from modules.representacao_social import process_representacao_social
from modules.goose_scraper import scrape_links
from modules.timeline_generator import TimelineGenerator, TimelineParser
from modules.entity_finder import EntityClassifier, process_text  # Importar funções de entity_finder

# Carregar variáveis de ambiente
load_dotenv()
openai_api_key = os.getenv("OPENAI_API_KEY")
if not openai_api_key:
    raise ValueError("A chave da API não foi encontrada. Verifique o arquivo .env.")

serp_api_key = os.getenv("SERP_API_KEY")
if not serp_api_key:
    raise ValueError("A chave da API não foi encontrada. Verifique o arquivo .env.")

# Inicializar o Flask
app = Flask(__name__)

# Configuração da pasta de upload
UPLOAD_FOLDER = './static/generated'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# Inicializar o EntityClassifier com a chave da OpenAI
entity_classifier = EntityClassifier(openai_api_key, serp_api_key)

# Variável global para armazenar conteúdo compartilhado
shared_content = {
    "text": None,
    "html_fixed": None,
    "html_dynamic": None,
    "algorithm": None,
    "bad_links": [],
    "timeline_file": None,
    "entities": None  # Adicionar campo para armazenar entidades
}

# Inicializar SentimentAnalyzer
sentiment_analyzer = SentimentAnalyzer(output_dir=UPLOAD_FOLDER)

@app.route('/')
def index():
    return render_template('index.html', shared_content=shared_content)

# >>>>>>> ROTAS DA INGESTÃO DE CONTEÚDOS <<<<<<<
@app.route('/ingest_content', methods=['POST'])
def ingest_content():
    global shared_content
    uploaded_file = request.files.get('file')
    text_input = request.form.get('text', '').strip()
    links_input = request.form.get('links', '').strip()

    sources_used = []
    if uploaded_file and uploaded_file.filename:
        sources_used.append('file')
    if text_input:
        sources_used.append('text')
    if links_input:
        sources_used.append('links')

    if len(sources_used) > 1:
        return jsonify({"status": "conflict", "sources": sources_used})

    if uploaded_file and uploaded_file.filename:
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], uploaded_file.filename)
        uploaded_file.save(filepath)
        with open(filepath, 'r', encoding='utf-8') as f:
            shared_content["text"] = f.read()
    elif text_input:
        shared_content["text"] = text_input
    elif links_input:
        links_list = [l.strip() for l in links_input.splitlines() if l.strip()]
        if links_list:
            try:
                combined_text, bad_links = scrape_links(links_list)
                shared_content["text"] = combined_text
                shared_content["bad_links"] = bad_links
            except Exception as e:
                return jsonify({"error": f"Erro ao raspar links: {str(e)}"}), 500

    shared_content["algorithm"] = "naive_bayes"
    shared_content["bad_links"] = []  # Zerar a lista de links ruins caso venha de arquivo/texto

    try:
        html_fixed, html_dynamic, num_pars, num_sents, analysis_ts = sentiment_analyzer.execute_analysis_text(
            shared_content["text"]
        )
        shared_content["html_fixed"] = html_fixed
        shared_content["html_dynamic"] = html_dynamic
        shared_content["timestamp"] = analysis_ts
        shared_content["counts"] = f"Parágrafos: {num_pars}, Frases: {num_sents}"

        return jsonify({"status": "success"})
    except Exception as e:
        print(f"Erro durante a ingestão de conteúdo: {e}")
        return jsonify({"error": "Erro ao processar o conteúdo"}), 500

@app.route('/ingest_links', methods=['POST'])
def ingest_links():
    global shared_content
    links_text = request.form.get('links', '')
    if not links_text.strip():
        return jsonify({"error": "Nenhum link fornecido"}), 400

    # Separar links por linha ou outro delimitador desejado
    links_list = [l.strip() for l in links_text.splitlines() if l.strip()]
    if not links_list:
        return jsonify({"error": "Nenhum link válido fornecido"}), 400

    # Raspagem de conteúdo usando o módulo goose_scraper
    try:
        combined_text, bad_links = scrape_links(links_list)
        shared_content["text"] = combined_text
        shared_content["bad_links"] = bad_links
    except Exception as e:
        print(f"Erro durante raspagem de links: {e}")
        return jsonify({"error": f"Erro ao raspar links: {str(e)}"}), 500

    # Ajuste para evitar erro 400 em /process_sentiment
    shared_content["algorithm"] = "naive_bayes"

    # Gerar conteúdo processado tal como é feito nas outras ingestões
    try:
        html_fixed, html_dynamic, num_pars, num_sents, analysis_ts = sentiment_analyzer.execute_analysis_text(
            shared_content["text"]
        )
        shared_content["html_fixed"] = html_fixed
        shared_content["html_dynamic"] = html_dynamic
        shared_content["timestamp"] = analysis_ts
        shared_content["counts"] = f"Parágrafos: {num_pars}, Frases: {num_sents}"

        # Retornamos também a lista de bad_links e os campos processados para o front-end
        return jsonify({
            "status": "success",
            "bad_links": bad_links,
            "html_fixed": {
                "analyzedText": html_fixed,
                "timestamp": analysis_ts,
                "counts": f"Parágrafos: {num_pars}, Frases: {num_sents}",
            },
            "html_dynamic": html_dynamic
        })
    except Exception as e:
        print(f"Erro durante a ingestão de conteúdo via links: {e}")
        return jsonify({"error": "Erro ao processar o conteúdo"}), 500

@app.route('/reset_content', methods=['POST'])
def reset_content():
    global shared_content
    shared_content = {
        "text": None, 
        "html_fixed": None, 
        "html_dynamic": None, 
        "algorithm": None, 
        "bad_links": [],
        "timeline_file": None,
        "entities": None  # Resetar entidades também
    }
    return jsonify({"status": "success"})

# >>>>>>> ROTAS DA ANÁLISE DE SENTIMENTOS <<<<<<<
@app.route('/process_sentiment', methods=['POST'])
def process_sentiment():
    """Processa a análise de sentimentos e retorna o conteúdo dinâmico gerado."""
    global shared_content
    if not shared_content.get("text"):
        return jsonify({"error": "No content provided"}), 400
    if not shared_content.get("algorithm"):
        return jsonify({"error": "No algorithm selected"}), 400

    try:
        # Verifica se os conteúdos fixo e dinâmico estão disponíveis
        if not shared_content.get("html_fixed") or not shared_content.get("html_dynamic"):
            raise ValueError("HTML content not generated yet.")

        return jsonify({
            "html_fixed": {
                "analyzedText": shared_content["html_fixed"],
                "timestamp": shared_content.get("timestamp", ""),
                "counts": shared_content.get("counts", ""),
            },
            "html_dynamic": shared_content["html_dynamic"]
        })
    except Exception as e:
        app.logger.error(f"Error processing sentiment analysis: {e}")
        return jsonify({"error": f"Processing error: {e}"}), 500

@app.route('/select_algorithm_and_generate', methods=['POST'])
def select_algorithm_and_generate():
    """Seleciona o algoritmo e realiza a análise de sentimentos."""
    global shared_content
    algorithm = request.form.get('algorithm', None)
    if not algorithm:
        return jsonify({"error": "Nenhum algoritmo selecionado"}), 400

    # Atualizar para permitir apenas o algoritmo Naive Bayes
    if algorithm != "naive_bayes":
        return jsonify({"error": "Algoritmo não suportado"}), 400

    shared_content["algorithm"] = algorithm

    # Validação do texto
    text = shared_content.get("text")
    if not text:
        return jsonify({"error": "Nenhum texto fornecido para análise"}), 400

    try:
        html_fixed, html_dynamic, num_pars, num_sents, analysis_ts = sentiment_analyzer.execute_analysis_text(text)
        shared_content["html_fixed"] = html_fixed
        shared_content["html_dynamic"] = html_dynamic
        shared_content["timestamp"] = analysis_ts
        shared_content["counts"] = f"Parágrafos: {num_pars}, Frases: {num_sents}"

        return jsonify({"status": "Análise concluída"})
    except ValueError as e:
        return jsonify({"error": str(e)}), 400

# >>>>>>> ROTAS DAS REPRESENTAÇÕES SOCIAIS <<<<<<<
@app.route('/process', methods=['POST'])
def process():
    """
    Rota para análise de Representação Social. 
    A funcionalidade foi movida para a função process_representacao_social,
    importada do script representacao_social.py.
    """
    global shared_content
    if not shared_content["text"]:
        return jsonify({"error": "No content provided"}), 400

    # Chama a função que faz todo o cálculo e retorna o HTML
    return process_representacao_social(
        shared_content["text"],
        request.form,
        app.config['UPLOAD_FOLDER']
    )

# >>>>>>> ROTAS DAS ENTIDADES E MAPA <<<<<<<
@app.route('/identify_entities', methods=['POST'])
def identify_entities():
    """Rota para identificar entidades e localidades."""
    global shared_content
    if not shared_content.get("text"):
        return jsonify({"error": "Nenhum texto fornecido para análise"}), 400

    try:
        # Processar texto para identificar entidades
        shared_content["entities"] = process_text(shared_content["text"], entity_classifier)
        return jsonify({"status": "success", "entities": shared_content["entities"]})
    except Exception as e:
        print(f"Erro durante a identificação de entidades: {e}")
        return jsonify({"error": "Erro ao identificar entidades"}), 500

# >>>>>>> ROTAS DA TIMELINE <<<<<<<
@app.route('/generate_timeline', methods=['POST'])
def generate_timeline():
    """
    Rota para gerar a timeline a partir do conteúdo de texto já ingerido.
    """
    global shared_content

    # Pega o que vier do front-end
    text = request.form.get("text", "")
    
    # Se vier vazio, tenta usar o que já está armazenado em shared_content
    if not text:
        text = shared_content.get("text", "")
    
    if not text.strip():
        return jsonify({"error": "Texto não fornecido"}), 400

    try:
        timeline_file = TimelineGenerator().create_timeline(text.splitlines())
        shared_content["timeline_file"] = timeline_file
        return jsonify({"status": "success", "timeline_file": timeline_file})
    except Exception as e:
        return jsonify({"error": f"Erro ao gerar timeline: {str(e)}"}), 500

@app.route('/view_timeline', methods=['GET'])
def view_timeline():
    """
    Rota para exibir a timeline gerada, agora retornando 'timeline.html' via JSON.
    """
    filename = request.args.get('file')
    if not filename:
        return jsonify({"status": "error", "message": "Nome do arquivo não fornecido"}), 400

    timeline_file = os.path.join("static/generated/timeline_output", filename)
    if not os.path.isfile(timeline_file):
        return jsonify({"status": "error", "message": f"Arquivo não encontrado: {timeline_file}"}), 404

    # Renderiza o template timeline.html
    html_str = render_template('timeline.html')
    return jsonify({"status": "success", "html": html_str, "filename": filename})

@app.route('/list_timelines')
def list_timelines():
    timeline_dir = "static/generated/timeline_output"
    try:
        timelines = [f for f in os.listdir(timeline_dir) if f.endswith('.timeline')]
        return jsonify({"status": "success", "timelines": timelines})
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/timeline_data')
def timeline_data():
    """
    Rota que parseia o arquivo .timeline e retorna os dados em JSON para o D3 desenhar.
    """
    filename = request.args.get('file')
    if not filename:
        return jsonify({"error": "Nome do arquivo não fornecido"}), 400

    timeline_file = os.path.join("static/generated/timeline_output", filename)
    if not os.path.isfile(timeline_file):
        return jsonify({"error": f"Arquivo não encontrado: {timeline_file}"}), 404

    parser = TimelineParser()
    try:
        data = parser.parse_timeline_xml(timeline_file)
        return jsonify(data)
    except Exception as e:
        return jsonify({"error": f"Falha ao parsear {timeline_file}: {str(e)}"}), 500

# >>>>>>> ROTA DO DOM <<<<<<<
@app.route('/api/', methods=['POST'])  # Altere 'api' para 'app' se necessário
def receive_dom():
    try:
        print("API: Received a POST request")
        # Recebe o conteúdo enviado em formato JSON
        data = request.get_json()
        print("API: JSON payload:", data)

        if not data:
            print("API: No JSON data received")
            return jsonify({"error": "No JSON data received"}), 400

        dom_content = data.get("dom", "")
        page_url = data.get("url", "Unknown URL")

        if not dom_content:
            print("API: No DOM content provided")
            return jsonify({"error": "No DOM content provided"}), 400

        # Apresenta o URL e o DOM recebido
        print(f"API: Received DOM from URL: {page_url}")
        print("API: Received DOM length:", len(dom_content))
        print("API: First 500 characters of DOM:")
        print(dom_content[:500])

        # Retorna confirmação
        return jsonify({"status": "success", "message": "DOM received"}), 200
    except Exception as e:
        print("API: Exception occurred:", e)
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    print(">>> Iniciando aplicação Flask em modo debug.")
    app.run(debug=True)

entity_finder.py  
import spacy
from summarizer import Summarizer
import nltk
from nltk.sentiment import SentimentIntensityAnalyzer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import KMeans
import numpy as np
import folium
from geopy.geocoders import Nominatim
from geopy.exc import GeocoderTimedOut, GeocoderServiceError
import time
import requests
import json
from openai import OpenAI

class EntityClassifier:
    """
    Classe responsável por gerenciar as etapas de classificação em lote (etapa 1)
    e de busca de imagem (etapa 2), utilizando a SerpAPI como abordagem principal.
    """
    def __init__(self, openai_api_key, serp_api_key):
        self.openai_client = OpenAI(api_key=openai_api_key)
        self.nlp = spacy.load("pt_core_news_sm")
        self.bert_model = Summarizer()
        self.sia = SentimentIntensityAnalyzer()
        self.geolocator = Nominatim(user_agent="my_flask_app/1.0")
        self.serp_api_key = serp_api_key

    def classificar_em_bloco(self, entidades_unicas):
        """
        Faz uma única chamada à API da OpenAI para classificar uma lista de entidades.
        Retorna um dicionário {entidade: {"tipo":..., "local":...}}.
        """
        print(">>> [ETAPA 1] classificar_entidades_em_bloco: Iniciando classificação em lote...")

        try:
            # Prompt que enfatiza a unicidade das entidades
            prompt_str = """
            Você receberá uma lista de entidades (pessoas, organizações ou localizações).
            Sintetize estas de maneira a eliminar duplicidades, verifique cada elemento, 
            identifique se este se trata de uma pessoa, organização ou localização e categorize-as.
            1) NÃO retorne entidades duplicadas. Cada entidade só pode aparecer uma única vez.
            2) Responda estritamente em JSON, no formato:
            {
                "resultado": [
                    {"entidade": "...", "tipo": "pessoa|organizacao|localizacao|desconhecido", "local": "... ou null"},
                    ...
                ]
            }
            Analise todas as entidades de entrada, garantindo a unicidade e se assegurando de 
            que cada uma apareça exatamente uma vez no array 'resultado', associada à sua respectiva categorização.
            """

            prompt_entidades = "Lista de entidades:\n" + "\n".join([f"- {e}" for e in entidades_unicas])
            prompt_final = prompt_str + "\n\n" + prompt_entidades

            print(">>> [ETAPA 1] classificar_entidades_em_bloco: Enviando para OpenAI GPT-4...")
            response = self.openai_client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt_final}]
            )
            conteudo = response.choices[0].message.content
            print("\n--- Resposta da API (etapa 1) ---")
            print(conteudo)

            data = json.loads(conteudo)
            classif_dict = {}
            for item in data.get("resultado", []):
                ent = item.get("entidade", "")
                tipo_raw = item.get("tipo", "desconhecido")
                loc_raw = item.get("local", None)

                tipo_map = {
                    "pessoa": "pessoa",
                    "organizacao": "organização",
                    "localizacao": "localização",
                    "desconhecido": "desconhecido"
                }
                tipo_final = tipo_map.get(tipo_raw, "desconhecido")
                loc_final = loc_raw if loc_raw != "null" else None
                classif_dict[ent] = {
                    "tipo": tipo_final,
                    "local": loc_final
                }

            print(">>> [ETAPA 1] Classificação em lote concluída.")
            return classif_dict

        except Exception as e:
            print(f"Erro na classificação em bloco: {e}")
            return {}

    def buscar_imagem_serpapi(self, query, tipo):
        """
        Busca de imagem na SerpAPI.
        """
        print(f">>> [ETAPA 2] buscar_imagem_serpapi: Buscando imagem para '{query}' como '{tipo}' via SerpAPI...")
        try:
            params = {
                "q": f"{query} {tipo}",
                "tbm": "isch",
                "api_key": self.serp_api_key
            }
            response = requests.get("https://serpapi.com/search", params=params)
            if response.status_code == 200:
                results = response.json()
                if "images_results" in results and len(results["images_results"]) > 0:
                    first_thumb = results["images_results"][0]["thumbnail"]
                    print(f">>> [ETAPA 2] buscar_imagem_serpapi: Imagem encontrada para '{query}': {first_thumb}")
                    return first_thumb
            print(f">>> [ETAPA 2] buscar_imagem_serpapi: Nenhuma imagem encontrada para '{query}'.")
            return None
        except Exception as e:
            print(f"Erro na SerpAPI: {e}")
            return None

def process_text(text, classifier):
    """
    Processa o texto para identificar entidades, sumarizar e gerar tópicos.
    """
    print(">>> Iniciando processamento de texto...")
    doc = classifier.nlp(text)
    entidades = [ent.text for ent in doc.ents]
    print(f">>> Entidades detectadas: {entidades}")

    # Classificação em lote
    entidades_unicas = list(set(entidades))
    classificacoes = classifier.classificar_em_bloco(entidades_unicas)

    entidades_classificadas = []
    for ent in entidades:
        if ent in classificacoes:
            etype = classificacoes[ent]["tipo"]
            elocal = classificacoes[ent]["local"]
            entidades_classificadas.append({"entidade": ent, "tipo": etype, "local": elocal})
        else:
            entidades_classificadas.append({"entidade": ent, "tipo": "desconhecido", "local": None})

    # Separar entidades em pessoas/organizações e localizações
    pessoas_organizacoes = [e for e in entidades_classificadas if e["tipo"] in ["pessoa", "organização"]]
    localizacoes = [e for e in entidades_classificadas if e["tipo"] == "localização"]

    # Análise de sentimento
    pessoas_organizacoes_com_sentimento = []
    for entidade_info in pessoas_organizacoes:
        sentimento = classifier.sia.polarity_scores(entidade_info["entidade"])
        pessoas_organizacoes_com_sentimento.append({
            **entidade_info,
            "sentimento": sentimento['compound']
        })

    localizacoes_com_sentimento = []
    for entidade_info in localizacoes:
        sentimento = classifier.sia.polarity_scores(entidade_info["entidade"])
        localizacoes_com_sentimento.append({
            **entidade_info,
            "sentimento": sentimento['compound']
        })

    # Geração de resumo com BERT
    resumo = classifier.bert_model(text)

    # Clustering de tópicos
    frases = [sent.text for sent in doc.sents]
    if len(frases) > 1:
        vectorizer = TfidfVectorizer(max_features=100, stop_words='english')
        X = vectorizer.fit_transform(frases)
        num_clusters = min(3, len(frases))
        kmeans = KMeans(n_clusters=num_clusters, random_state=42)
        kmeans.fit(X)
        clusters = kmeans.labels_

        topicos = {}
        for i, c in enumerate(clusters):
            if c not in topicos:
                topicos[c] = []
            topicos[c].append(frases[i])

        topicos_principais = []
        for c in topicos:
            centroide = np.mean(X[clusters == c], axis=0)
            indice_representante = np.argmin(
                np.linalg.norm(X[clusters == c] - centroide, axis=1)
            )
            topicos_principais.append(topicos[c][indice_representante])
    else:
        topicos_principais = ["Não há frases suficientes para clustering."]

    # Busca de imagens para cada entidade
    pessoas_organizacoes_com_imagens = []
    for entidade_info in pessoas_organizacoes_com_sentimento:
        image_link = classifier.buscar_imagem_serpapi(entidade_info["entidade"], entidade_info["tipo"])
        pessoas_organizacoes_com_imagens.append({**entidade_info, "imagem": image_link})

    localizacoes_com_imagens = []
    for entidade_info in localizacoes_com_sentimento:
        image_link = classifier.buscar_imagem_serpapi(entidade_info["entidade"], "localização")
        localizacoes_com_imagens.append({**entidade_info, "imagem": image_link})

    return {
        "pessoas": pessoas_organizacoes_com_imagens,
        "localizacoes": localizacoes_com_imagens,
        "resumo": resumo,
        "topicos": topicos_principais
    }

index.html  
<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ephor - Análise de Conteúdo</title>
    <!-- CSS do Bootstrap -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/css/bootstrap.min.css">
    <!-- CSS do DataTables -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
    <!-- CSS específico para a Timeline -->
    <link rel="stylesheet" href="/static/css/timeline.css">
    <!-- Outros links de CSS, se houver -->
    <!-- Incluir D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container mt-5">
        <h1 class="mb-4">Ephor - Análise de Conteúdo</h1>

        <!-- Área de ingestão de texto ou visualização de conteúdo fixo -->
        <div id="ingestContent" class="mb-4">
            <form id="ingestForm">
                <!-- Abas para escolha da fonte de texto -->
                <ul class="nav nav-tabs" id="ingestTabs" role="tablist">
                    <li class="nav-item">
                        <button class="nav-link active" id="file-tab" data-bs-toggle="tab" data-bs-target="#fileContent" type="button" role="tab" aria-controls="fileContent" aria-selected="true">
                            Texto via Arquivo
                        </button>
                    </li>
                    <li class="nav-item">
                        <button class="nav-link" id="text-tab" data-bs-toggle="tab" data-bs-target="#textContent" type="button" role="tab" aria-controls="textContent" aria-selected="false">
                            Texto Copiado
                        </button>
                    </li>
                    <li class="nav-item">
                        <button class="nav-link" id="links-tab" data-bs-toggle="tab" data-bs-target="#linksContent" type="button" role="tab" aria-controls="linksContent" aria-selected="false">
                            Texto de Links
                        </button>
                    </li>
                </ul>

                <div class="tab-content p-3 border border-top-0" id="ingestTabContent">
                    <!-- Aba: Texto via Arquivo -->
                    <div class="tab-pane fade show active" id="fileContent" role="tabpanel" aria-labelledby="file-tab">
                        <div class="mb-3">
                            <label for="inputFile" class="form-label">Carregar Arquivo de Texto</label>
                            <input type="file" id="inputFile" name="file" class="form-control" accept=".txt">
                        </div>
                    </div>

                    <!-- Aba: Texto Copiado -->
                    <div class="tab-pane fade" id="textContent" role="tabpanel" aria-labelledby="text-tab">
                        <div class="mb-3">
                            <label for="inputText" class="form-label">Cole Texto Aqui</label>
                            <textarea id="inputText" name="text" class="form-control" rows="5"></textarea>
                        </div>
                    </div>

                    <!-- Aba: Texto de Links -->
                    <div class="tab-pane fade" id="linksContent" role="tabpanel" aria-labelledby="links-tab">
                        <div class="mb-3">
                            <label for="linksArea" class="form-label">Insira os links aqui (um por linha)</label>
                            <textarea id="linksArea" name="links" class="form-control" rows="5"></textarea>
                        </div>
                        <div id="linksErrorList" class="text-danger mt-3" style="display: none;"></div>
                        <div id="loadingMessage" class="text-primary mt-3" style="display: none;">
                            <p>Aguarde enquanto processamos os links...</p>
                        </div>
                    </div>
                </div>

                <button type="button" id="ingestBtn" class="btn btn-primary mt-3">Enviar Conteúdo</button>
            </form>
        </div>

        <!-- Exibição de conteúdo fixo -->
        <div id="fixedContent" class="mb-4 d-none">
            <div id="analyzedText" class="border p-3 mb-3" style="white-space: pre-wrap; max-height: 400px; overflow-y: auto;"></div>
            <div id="timestamp" class="border p-3 mb-3"></div>
            <div id="counts" class="border p-3 mb-3"></div>
            <button type="button" id="resetBtn" class="btn btn-warning">Enviar Outro Conteúdo</button>
        </div>

        <!-- Abas para as análises e para a timeline -->
        <ul class="nav nav-tabs" id="analysisTabs" role="tablist">
            <li class="nav-item">
                <button class="nav-link active" id="entities-tab" data-bs-toggle="tab" data-bs-target="#entities" type="button" role="tab" aria-controls="entities" aria-selected="true">
                    Entidades e Localidades
                </button>
            </li>
            <li class="nav-item">
                <button class="nav-link" id="timeline-tab" data-bs-toggle="tab" data-bs-target="#timeline" type="button" role="tab" aria-controls="timeline" aria-selected="false">
                    Geração de Timeline
                </button>
            </li>
            <li class="nav-item">
                <button class="nav-link" id="sentiment-tab" data-bs-toggle="tab" data-bs-target="#sentiment" type="button" role="tab" aria-controls="sentiment" aria-selected="false">
                    Análise de Sentimentos
                </button>
            </li>
            <li class="nav-item">
                <button class="nav-link" id="content-tab" data-bs-toggle="tab" data-bs-target="#content" type="button" role="tab" aria-controls="content" aria-selected="false">
                    Representação Social
                </button>
            </li>
        </ul>

        <div class="tab-content mt-3">
            <!-- Aba de Entidades e Localidades -->
            <div class="tab-pane fade show active" id="entities" role="tabpanel" aria-labelledby="entities-tab">
                <button type="button" id="identifyEntitiesBtn" class="btn btn-primary mt-3">Identificar Entidades</button>
                <div id="entitiesResults" class="mt-3">
                    <!-- O conteúdo de entidades e localidades será inserido aqui via AJAX -->
                </div>
            </div>

            <!-- Aba de Geração de Timeline -->
            <div class="tab-pane fade" id="timeline" role="tabpanel" aria-labelledby="timeline-tab">
                <form id="timelineForm">
                    <div class="mb-3">
                        <label for="timelineDropdown" class="form-label">Timelines Disponíveis</label>
                        <select id="timelineDropdown" name="timelineDropdown" class="form-select" onfocus="loadTimelineList()">
                            <!-- As timelines serão carregadas aqui via JavaScript -->
                        </select>
                    </div>
                    <button type="button" id="timelineBtn" class="btn btn-primary">Gerar Timeline</button>
                </form>
                <div id="timelineResults" class="mt-3">
                    <!-- O conteúdo da timeline (HTML do template) será inserido aqui via AJAX -->
                </div>
            </div>

            <!-- Aba de Análise de Sentimentos -->
            <div class="tab-pane fade" id="sentiment" role="tabpanel" aria-labelledby="sentiment-tab">
                <form id="sentimentForm">
                    <div class="mb-3">
                        <label for="algorithm" class="form-label">Selecione o Algoritmo</label>
                        <select id="algorithm" name="algorithm" class="form-select">
                            <option value="naive_bayes" selected>Naive Bayes</option>
                        </select>
                    </div>
                    <button type="button" id="sentimentBtn" class="btn btn-primary">Gerar Análise</button>
                </form>
                <div id="sentimentResults" class="mt-3"></div>
            </div>

            <!-- Aba de Representação Social -->
            <div class="tab-pane fade" id="content" role="tabpanel" aria-labelledby="content-tab">
                <form id="contentForm">
                    <div class="mb-3">
                        <label for="stopwords" class="form-label">Filtro de Stopwords</label>
                        <select id="stopwords" name="stopwords" class="form-select">
                            <option value="com">Com Stopwords</option>
                            <option value="sem">Sem Stopwords</option>
                            <option value="stopwords">Apenas Stopwords</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="zone" class="form-label">Filtro de Zonas</label>
                        <select id="zone" name="zone" class="form-select">
                            <option value="Núcleo Central">Núcleo Central</option>
                            <option value="Zona Periférica 1">Zona Periférica 1</option>
                            <option value="Zona Periférica 2">Zona Periférica 2</option>
                            <option value="Zona Periférica 3">Zona Periférica 3</option>
                            <option value="todas">Todas as Zonas</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="extraFilter" class="form-label">Filtro Extra</label>
                        <select id="extraFilter" name="extra_filter" class="form-select">
                            <option value="nao">Não Aplicar</option>
                            <option value="sim">Remover Números e Emojis</option>
                        </select>
                    </div>
                    <button type="button" id="contentBtn" class="btn btn-primary">Gerar Análise</button>
                </form>
                <div id="contentResults" class="mt-3"></div>
            </div>
        </div>
    </div>

    <!-- Scripts JavaScript -->
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- DataTables JS -->
    <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
    <!-- JavaScript específico da aplicação -->
    <script src="/static/js/app.js"></script>
    <!-- Timeline JS -->
    <script src="/static/js/timeline.js"></script>
    <!-- Bootstrap JS Bundle (inclui Popper) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/js/bootstrap.bundle.min.js"></script>
</body>
</html>

app.js  
// Função para carregar a lista de timelines disponíveis (agora global)
function loadTimelineList() {
    $.ajax({
        url: '/list_timelines', // Rota para listar os arquivos de timeline
        type: 'GET',
        success: function (data) {
            const timelineDropdown = $('#timelineDropdown');
            timelineDropdown.empty(); // Limpa o dropdown atual
            if (data.timelines && data.timelines.length > 0) {
                data.timelines.forEach(timeline => {
                    const option = $(`<option value="${timeline}">${timeline}</option>`);
                    timelineDropdown.append(option);
                });
            } else {
                timelineDropdown.append('<option value="">Nenhuma timeline disponível</option>');
            }
        },
        error: function () {
            alert("Erro ao carregar a lista de timelines. Verifique o servidor.");
        }
    });
}

$(document).ready(function () {
    const ingestContent = $('#ingestContent');
    const fixedContent = $('#fixedContent');
    const analyzedText = $('#analyzedText');
    const timestamp = $('#timestamp');
    const counts = $('#counts');
    const linksErrorList = $('#linksErrorList');

    // Função para carregar uma timeline específica
    function loadTimeline(filename) {
        $.ajax({
            url: `/view_timeline?file=${filename}`,
            type: 'GET',
            dataType: 'json',
            success: function (data) {
                if (data.status === "success") {
                    $('#timelineResults').html(data.html); // Exibe a timeline
                    // Chama a função para carregar os dados da timeline
                    fetchTimelineData(filename);
                } else {
                    alert("Erro ao carregar a timeline: " + data.error);
                }
            },
            error: function () {
                alert("Erro ao carregar a timeline. Verifique o servidor.");
            }
        });
    }

    // Função para buscar os dados da timeline
    function fetchTimelineData(filename) {
        $.ajax({
            url: `/timeline_data?file=${filename}`,
            type: 'GET',
            dataType: 'json',
            success: function (data) {
                if (data) {
                    drawTimeline(data); // Desenha a timeline com os dados recebidos
                } else {
                    alert("Erro ao carregar os dados da timeline.");
                }
            },
            error: function (xhr, status, error) {
                console.error("Erro ao buscar os dados da timeline:", error);
                alert("Erro ao buscar os dados da timeline. Verifique o servidor.");
            }
        });
    }

    // Função para mostrar popup de decisão (adaptada para três fontes)
    function showSourceConflictPopup(options, onSelect) {
        let message = '<p>Detectamos que você preencheu mais de uma fonte de texto:</p><ul>';
        options.forEach(opt => {
            if (opt === 'file') message += '<li>Arquivo</li>';
            if (opt === 'text') message += '<li>Texto Copiado</li>';
            if (opt === 'links') message += '<li>Links</li>';
        });
        message += '</ul><p>Por favor, escolha qual fonte deseja usar:</p>';

        let popup = $(
            `<div id="sourceConflictPopup" style="position: fixed; top: 50%; left: 50%; 
                 transform: translate(-50%, -50%); background: white; padding: 20px; 
                 border: 1px solid #ccc; box-shadow: 0px 4px 6px rgba(0,0,0,0.1); 
                 z-index: 9999;">
                <h5>Conflito de fontes de texto</h5>
                ${message}
            </div>`
        );

        options.forEach(opt => {
            let label = '';
            if (opt === 'file') label = 'Usar Arquivo';
            if (opt === 'text') label = 'Usar Texto Copiado';
            if (opt === 'links') label = 'Usar Links';
            let btn = $(`<button class="btn btn-primary m-1">${label}</button>`);
            btn.on('click', function () {
                popup.remove();
                onSelect(opt);
            });
            popup.append(btn);
        });

        $('body').append(popup);
    }

    function processSentiment() {
        $.ajax({
            url: '/process_sentiment',
            type: 'POST',
            success: function (data) {
                if (data.html_fixed && data.html_dynamic) {
                    analyzedText.html(data.html_fixed.analyzedText || "Erro ao carregar texto analisado.");
                    timestamp.html(data.html_fixed.timestamp || "Erro ao carregar timestamp.");
                    counts.html(data.html_fixed.counts || "Erro ao carregar contagem.");
                    $('#sentimentResults').html(data.html_dynamic);
                    fixedContent.removeClass('d-none'); // Certificar que o conteúdo é exibido
                } else {
                    alert("Erro ao processar os resultados. Verifique o servidor.");
                }
            },
            error: function () {
                alert("Erro ao processar a análise de sentimentos. Verifique o servidor.");
            }
        });
    }

    // Botão de Enviar Conteúdo
    $('#ingestBtn').on('click', function () {
        linksErrorList.empty().hide();

        const fileInput = $('#inputFile').val();
        const textInput = $('#inputText').val().trim();
        const linksInput = $('#linksArea').val().trim();

        let sourcesUsed = [];
        if (fileInput) sourcesUsed.push('file');
        if (textInput) sourcesUsed.push('text');
        if (linksInput) sourcesUsed.push('links');

        // Verificar o formato do arquivo se selecionado
        if (fileInput && !fileInput.endsWith('.txt')) {
            alert('Apenas arquivos .txt são permitidos.');
            return;
        }

        if (sourcesUsed.length > 1) {
            showSourceConflictPopup(sourcesUsed, (selectedSource) => {
                if (selectedSource === 'file') {
                    let formData = new FormData($('#ingestForm')[0]);
                    formData.delete('text');
                    formData.delete('links');
                    $.ajax({
                        url: '/ingest_content',
                        type: 'POST',
                        data: formData,
                        processData: false,
                        contentType: false,
                        success: function () {
                            ingestContent.addClass('d-none');
                            processSentiment();
                        },
                        error: function () {
                            alert("Erro ao enviar conteúdo (arquivo). Verifique o servidor.");
                        }
                    });
                } else if (selectedSource === 'text') {
                    let formData = new FormData();
                    formData.append('text', textInput);
                    $.ajax({
                        url: '/ingest_content',
                        type: 'POST',
                        data: formData,
                        processData: false,
                        contentType: false,
                        success: function () {
                            ingestContent.addClass('d-none');
                            processSentiment();
                        },
                        error: function () {
                            alert("Erro ao enviar conteúdo (texto). Verifique o servidor.");
                        }
                    });
                } else if (selectedSource === 'links') {
                    let formData = new FormData();
                    formData.append('links', linksInput);

                    // Exibir mensagem de aguarde
                    const loadingMessage = $('<p class="text-primary">Aguarde enquanto processamos os links...</p>');
                    ingestContent.append(loadingMessage);

                    $.ajax({
                        url: '/ingest_links',
                        type: 'POST',
                        data: formData,
                        processData: false,
                        contentType: false,
                        success: function (data) {
                            loadingMessage.remove();
                            ingestContent.addClass('d-none');
                            if (data.html_fixed) {
                                analyzedText.html(data.html_fixed.analyzedText || "Erro ao carregar texto analisado.");
                                timestamp.html(data.html_fixed.timestamp || "Erro ao carregar timestamp.");
                                counts.html(data.html_fixed.counts || "Erro ao carregar contagem.");
                            }
                            if (data.bad_links && data.bad_links.length > 0) {
                                linksErrorList.html(
                                    "<strong>Links com falha ou sem conteúdo:</strong><br>" +
                                    data.bad_links.join("<br>")
                                ).show();
                            }
                            fixedContent.removeClass('d-none');
                        },
                        error: function () {
                            loadingMessage.remove();
                            alert("Erro ao enviar conteúdo (links). Verifique o servidor.");
                        }
                    });
                }
            });
        } else {
            if (fileInput) {
                let formData = new FormData($('#ingestForm')[0]);
                $.ajax({
                    url: '/ingest_content',
                    type: 'POST',
                    data: formData,
                    processData: false,
                    contentType: false,
                    success: function () {
                        ingestContent.addClass('d-none');
                        processSentiment();
                    },
                    error: function () {
                        alert("Erro ao enviar conteúdo (arquivo). Verifique o servidor.");
                    }
                });
            } else if (textInput) {
                let formData = new FormData();
                formData.append('text', textInput);
                $.ajax({
                    url: '/ingest_content',
                    type: 'POST',
                    data: formData,
                    processData: false,
                    contentType: false,
                    success: function () {
                        ingestContent.addClass('d-none');
                        processSentiment();
                    },
                    error: function () {
                        alert("Erro ao enviar conteúdo (texto). Verifique o servidor.");
                    }
                });
            } else if (linksInput) {
                let formData = new FormData();
                formData.append('links', linksInput);

                // Exibir mensagem de aguarde
                const loadingMessage = $('<p class="text-primary">Aguarde enquanto processamos os links...</p>');
                ingestContent.append(loadingMessage);

                $.ajax({
                    url: '/ingest_links',
                    type: 'POST',
                    data: formData,
                    processData: false,
                    contentType: false,
                    success: function (data) {
                        loadingMessage.remove();
                        ingestContent.addClass('d-none');
                        if (data.html_fixed) {
                            analyzedText.html(data.html_fixed.analyzedText || "Erro ao carregar texto analisado.");
                            timestamp.html(data.html_fixed.timestamp || "Erro ao carregar timestamp.");
                            counts.html(data.html_fixed.counts || "Erro ao carregar contagem.");
                        }
                        if (data.bad_links && data.bad_links.length > 0) {
                            linksErrorList.html(
                                "<strong>Links com falha ou sem conteúdo:</strong><br>" +
                                data.bad_links.join("<br>")
                            ).show();
                        }
                        fixedContent.removeClass('d-none');
                    },
                    error: function () {
                        loadingMessage.remove();
                        alert("Erro ao enviar conteúdo (links). Verifique o servidor.");
                    }
                });
            } else {
                alert("Nenhuma fonte de conteúdo fornecida.");
            }
        }
    });

    // Botão de Reset
    $('#resetBtn').on('click', function () {
        $.post('/reset_content', function () {
            fixedContent.addClass('d-none');
            ingestContent.removeClass('d-none');
            $('#inputText').val('');
            $('#inputFile').val('');
            $('#linksArea').val('');
            linksErrorList.empty().hide();
        });
    });

    // Botão de Análise de Representação Social
    $('#contentBtn').on('click', function () {
        const formData = new FormData($('#contentForm')[0]);
        $.ajax({
            url: '/process',
            type: 'POST',
            data: formData,
            processData: false,
            contentType: false,
            success: function (data) {
                $('#contentResults').html(data.html);
                $('#contentResults table').each(function () {
                    const columnCount = $(this).find('thead th').length;
                    if (columnCount > 0) {
                        $(this).DataTable({
                            paging: false,
                            info: false,
                            searching: false,
                        });
                    }
                });
            },
            error: function () {
                alert("Erro ao processar representação social. Verifique o servidor.");
            }
        });
    });

    // Botão de Análise de Sentimentos
    $('#sentimentBtn').on('click', function () {
        const formData = new FormData($('#sentimentForm')[0]);
        $.ajax({
            url: '/select_algorithm_and_generate',
            type: 'POST',
            data: formData,
            processData: false,
            contentType: false,
            success: function () {
                $.ajax({
                    url: '/process_sentiment',
                    type: 'POST',
                    success: function (data) {
                        $('#sentimentResults').html(data.html_dynamic);
                    },
                    error: function () {
                        alert("Erro ao processar a análise de sentimentos. Verifique o servidor.");
                    }
                });
            },
            error: function () {
                alert("Erro ao selecionar o algoritmo. Verifique o servidor.");
            }
        });
    });

    // Botão de Geração de Timeline
    $('#timelineBtn').on('click', function () {
        const textInput = $('#inputText').val().trim();

        $.ajax({
            url: '/generate_timeline',
            type: 'POST',
            data: { text: textInput },
            success: function (data) {
                if (data.status === "success") {
                    // Carrega a timeline gerada
                    loadTimeline(data.timeline_file);
                    // Atualiza a lista de timelines
                    loadTimelineList();
                } else {
                    alert("Falha na geração da timeline: " + data.error);
                }
            },
            error: function () {
                alert("Erro ao gerar timeline. Verifique o servidor.");
            }
        });
    });

    // Botão de Identificar Entidades
    $('#identifyEntitiesBtn').on('click', function () {
        $.ajax({
            url: '/identify_entities',
            type: 'POST',
            success: function (data) {
                if (data.status === "success") {
                    // Atualiza o conteúdo da aba com as entidades identificadas
                    $('#entitiesResults').html(renderEntities(data.entities));
                } else {
                    alert("Erro ao identificar entidades. Verifique o servidor.");
                }
            },
            error: function () {
                alert("Erro ao identificar entidades. Verifique o servidor.");
            }
        });
    });

    // Função para renderizar as entidades identificadas
    function renderEntities(entities) {
        let html = '<div class="coluna">';
        if (entities.topicos && entities.topicos.length > 0) {
            html += '<h2>Tópicos Principais:</h2><ul>';
            entities.topicos.forEach(topico => {
                html += `<li>${topico}</li>`;
            });
            html += '</ul>';
        }
        if (entities.resumo) {
            html += `<h2>Resumo:</h2><p>${entities.resumo}</p>`;
        }
        if (entities.pessoas && entities.pessoas.length > 0) {
            html += '<h2>Pessoas e Organizações:</h2><ul>';
            entities.pessoas.forEach(pessoa => {
                html += `
                    <li class="entidade">
                        <strong>${pessoa.entidade}</strong>
                        <span class="emoji">
                            ${pessoa.sentimento > 0.05 ? '😊' : pessoa.sentimento < -0.05 ? '😠' : '😐'}
                        </span>
                        ${pessoa.imagem ? `<img src="${pessoa.imagem}" alt="${pessoa.entidade}" class="imagem-miniatura">` : ''}
                    </li>`;
            });
            html += '</ul>';
        }
        if (entities.localizacoes && entities.localizacoes.length > 0) {
            html += '<h2>Localizações:</h2><ul>';
            entities.localizacoes.forEach(loc => {
                html += `
                    <li class="entidade">
                        <strong>${loc.entidade}</strong>
                        <span class="emoji">
                            ${loc.sentimento > 0.05 ? '😊' : loc.sentimento < -0.05 ? '😠' : '😐'}
                        </span>
                        ${loc.imagem ? `<img src="${loc.imagem}" alt="${loc.entidade}" class="imagem-miniatura">` : ''}
                    </li>`;
            });
            html += '</ul>';
        }
        html += '</div>';
        return html;
    }
});

app.css  
/* Estilos gerais */
body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f9;
    margin: 0;
    padding: 20px;
    color: #333;
}

h1, h2 {
    color: #2c3e50;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: #fff;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
}

/* Formulário */
form {
    margin-bottom: 20px;
}

textarea {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
    resize: vertical;
}

button {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #3498db;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background-color: #2980b9;
}

/* Colunas */
.coluna {
    margin-bottom: 20px;
}

.coluna h2 {
    margin-bottom: 10px;
    font-size: 24px;
    color: #34495e;
}

/* Listas de entidades */
.entidade {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    padding: 10px;
    background-color: #ecf0f1;
    border-radius: 4px;
}

.entidade strong {
    font-size: 18px;
    color: #2c3e50;
}

.emoji {
    font-size: 20px;
}

.imagem-miniatura {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    transition: transform 0.3s;
    cursor: pointer;
}

.imagem-miniatura:hover {
    transform: scale(2);
}

/* Mapa */
.mapa-container {
    width: 100%;
    height: 500px;
    border-radius: 8px;
    overflow: hidden;
    margin-top: 20px;
}

/* Mensagem de processamento */
#processing {
    background-color: #ecf0f1;
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 20px;
    color: #34495e;
    font-style: italic;
}

/* Responsividade */
@media (max-width: 768px) {
    .container {
        padding: 10px;
    }

    .coluna {
        flex-direction: column;
    }

    .entidade {
        flex-direction: column;
        align-items: flex-start;
    }

    .imagem-miniatura {
        width: 40px;
        height: 40px;
    }
}

entities_and_locations.html  
<div class="container">
    <h1>Entidades e Localidades</h1>

    <!-- Tópicos Principais -->
    <div class="coluna">
        <h2>Tópicos Principais:</h2>
        <ul>
            {% for topico in entities.topicos %}
            <li>{{ topico }}</li>
            {% endfor %}
        </ul>
    </div>

    <!-- Resumo -->
    <div class="coluna">
        <h2>Resumo:</h2>
        <p>{{ entities.resumo }}</p>
    </div>

    <!-- Pessoas e Organizações -->
    <div class="coluna">
        <h2>Pessoas e Organizações:</h2>
        <ul>
            {% for pessoa in entities.pessoas %}
                <li class="entidade">
                    <strong>{{ pessoa.entidade }}</strong>
                    <span class="emoji">
                        {% if pessoa.sentimento > 0.05 %}
                            😊
                        {% elif pessoa.sentimento < -0.05 %}
                            😠
                        {% else %}
                            😐
                        {% endif %}
                    </span>
                    {% if pessoa.imagem %}
                        <img 
                            src="{{ pessoa.imagem }}" 
                            alt="{{ pessoa.entidade }}" 
                            class="imagem-miniatura"
                        >
                    {% endif %}
                </li>
            {% endfor %}
        </ul>
    </div>

    <!-- Localizações -->
    <div class="coluna">
        <h2>Localizações:</h2>
        <ul>
            {% for loc in entities.localizacoes %}
                <li class="entidade">
                    <strong>{{ loc.entidade }}</strong>
                    <span class="emoji">
                        {% if loc.sentimento > 0.05 %}
                            😊
                        {% elif loc.sentimento < -0.05 %}
                            😠
                        {% else %}
                            😐
                        {% endif %}
                    </span>
                    {% if loc.imagem %}
                        <img 
                            src="{{ loc.imagem }}" 
                            alt="{{ loc.entidade }}" 
                            class="imagem-miniatura"
                        >
                    {% endif %}
                </li>
            {% endfor %}
        </ul>
    </div>

    <!-- Mapa de Localizações -->
    <div class="coluna">
        <h2>Mapa de Localizações:</h2>
        <div class="mapa-container">
            <iframe src="/mapa" width="100%" height="100%"></iframe>
        </div>
    </div>
</div>

timeline.html
<!-- timeline.html: Partial Template -->
<h2>Visualização da Linha do Tempo</h2>
<div id="timelineContainer"></div> <!-- Container principal para a timeline -->
<div class="category-box" id="category-box"></div> <!-- Caixa de categorias para filtragem -->
<div class="event-description" id="event-description"></div> <!-- Tooltip para descrições dos eventos -->

<!-- Importamos o timeline.js AO FINAL, para ele rodar após DOM pronto -->
<script src="/static/js/timeline.js"></script>

timeline.js
// Variável global para a escala de tempo
let timeScale;

// Função principal de desenho da timeline
function drawTimeline(data) {
    // Permite rolagem se exceder dimensões
    const container = d3.select("#timelineContainer")
        .style("overflow", "auto")
        .style("max-height", "600px");

    // Dimensões "grandes" para acomodar bastante espaço
    const svgWidth = 2000;
    const svgHeight = 800;

    // Verifica se as datas de início e fim estão presentes no XML
    const startDate = data.view && data.view.start ? new Date(data.view.start) : new Date();
    const endDate = data.view && data.view.end ? new Date(data.view.end) : new Date(startDate.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 ano após a data de início

    // Escala de tempo dinâmica
    timeScale = d3.scaleTime()
        .domain([startDate, endDate])
        .range([0, svgWidth]);

    // Cria SVG
    const svg = container.append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .style("background", "#fff");

    // Desenho das Eras (se presentes no XML)
    if (data.eras && data.eras.length > 0) {
        data.eras.forEach(era => {
            const eraStart = era.start ? timeScale(new Date(era.start)) : 0;
            const eraEnd = era.end ? timeScale(new Date(era.end)) : svgWidth;
            const rectWidth = Math.max(1, eraEnd - eraStart);

            // Fundo suave para a era
            svg.append("rect")
                .attr("x", eraStart)
                .attr("width", rectWidth)
                .attr("y", svgHeight / 2 - 50)
                .attr("height", 100)
                .attr("fill", "rgba(173, 216, 230, 0.3)")
                .attr("class", "era");

            // Texto da era (se presente)
            if (era.name) {
                svg.append("text")
                    .attr("x", eraStart + 10)
                    .attr("y", (svgHeight / 2) - 55)
                    .attr("fill", "#000")
                    .style("font-size", "12px")
                    .text(era.name);
            }

            // Linhas de início/fim da era
            svg.append("line")
                .attr("x1", eraStart)
                .attr("x2", eraStart)
                .attr("y1", 0)
                .attr("y2", svgHeight)
                .style("stroke", "#222")
                .style("stroke-width", 3);

            svg.append("line")
                .attr("x1", eraEnd)
                .attr("x2", eraEnd)
                .attr("y1", 0)
                .attr("y2", svgHeight)
                .style("stroke", "#222")
                .style("stroke-width", 3);
        });
    } else {
        // Se não houver eras, desenha uma única linha central
        svg.append("line")
            .attr("x1", 0)
            .attr("x2", svgWidth)
            .attr("y1", svgHeight / 2)
            .attr("y2", svgHeight / 2)
            .attr("stroke", "#000")
            .attr("stroke-width", 2);
    }

    // Desenho dos Eventos (se presentes no XML)
    if (data.events && data.events.length > 0) {
        const eventGroup = svg.append("g").attr("class", "events");
        const occupiedLevels = [];

        // Ordena eventos pela data de início
        const sortedEvents = data.events.slice().sort((a, b) => {
            const aStart = a.start ? new Date(a.start).getTime() : 0;
            const bStart = b.start ? new Date(b.start).getTime() : 0;
            return aStart - bStart;
        });

        sortedEvents.forEach(event => {
            const startX = event.start ? timeScale(new Date(event.start)) : 0;
            const endX = event.end ? timeScale(new Date(event.end)) : startX + 100; // Largura padrão se não houver data de fim
            const rawWidth = endX - startX;
            const eventWidth = Math.max(40, rawWidth);

            // Mede texto para dimensionar retângulo
            const tempText = eventGroup.append("text")
                .attr("x", -9999)
                .attr("y", -9999)
                .style("font-size", "12px")
                .text(event.text || "Evento sem descrição");
            const textBBox = tempText.node().getBBox();
            tempText.remove();

            const rectHeight = textBBox.height + 8;
            const neededWidth = textBBox.width + 10;
            const finalWidth = Math.max(eventWidth, neededWidth);

            // Empilhamento acima/abaixo da linha central
            let yOffset = svgHeight / 2;
            let level = 0;
            while (
                occupiedLevels[level] &&
                occupiedLevels[level].some(range => overlaps(range, {
                    startX: startX,
                    endX: startX + finalWidth,
                    top: yOffset,
                    bottom: yOffset + rectHeight
                }))
            ) {
                level++;
                const direction = level % 2 === 0 ? -1 : 1;
                const offset = 40 + (level * 25);
                yOffset = (svgHeight / 2) + (direction * offset);
            }
            if (!occupiedLevels[level]) occupiedLevels[level] = [];

            // Se sobrepõe, alarga o evento mais antigo
            occupiedLevels[level].forEach(existing => {
                if (overlaps(existing, {
                    startX: startX,
                    endX: startX + finalWidth,
                    top: yOffset,
                    bottom: yOffset + rectHeight
                })) {
                    existing.rectRef.attr("height", parseFloat(existing.rectRef.attr("height")) + 5);
                }
            });

            const eventRect = eventGroup.append("rect")
                .attr("x", startX)
                .attr("y", yOffset)
                .attr("width", finalWidth)
                .attr("height", rectHeight)
                .attr("fill", data.categories && data.categories[event.category] ? data.categories[event.category].color : "#ccc")
                .attr("stroke", "#555")
                .attr("stroke-width", 1)
                .attr("class", `event-${event.category || "default"}`)
                .on("mouseover", (e) => showDescription(event, e))
                .on("mouseout", hideDescription);

            eventGroup.append("text")
                .attr("x", startX + 5)
                .attr("y", yOffset + (rectHeight / 2) + (textBBox.height * 0.35))
                .attr("fill", "#000")
                .style("font-size", "12px")
                .text(event.text || "Evento sem descrição");

            occupiedLevels[level].push({
                startX,
                endX: startX + finalWidth,
                top: yOffset,
                bottom: yOffset + rectHeight,
                rectRef: eventRect
            });
        });
    }

    // Linha central
    svg.append("line")
        .attr("x1", 0)
        .attr("x2", svgWidth)
        .attr("y1", svgHeight / 2)
        .attr("y2", svgHeight / 2)
        .attr("stroke", "#000")
        .attr("stroke-width", 2);

    // Adiciona a linha de referência horizontal com datas/tempos dinâmicos
    addTimeAxis(svg, startDate, endDate);

    // Eixo superior semanal
    addWeekAxis(svg, startDate, endDate);
}

// Função para verificar sobreposição
function overlaps(range1, range2) {
    const hOverlap = range1.startX < range2.endX && range1.endX > range2.startX;
    const vOverlap = range1.top < range2.bottom && range1.bottom > range2.top;
    return hOverlap && vOverlap;
}

// Função para adicionar o eixo de tempo dinâmico
function addTimeAxis(svg, startDate, endDate) {
    const stepMs = getDynamicStep(startDate, endDate);
    let current = new Date(startDate);

    while (current <= endDate) {
        const xPos = timeScale(current);

        // Desenha a linha vertical pontilhada para cada divisão
        svg.append("line")
            .attr("x1", xPos)
            .attr("x2", xPos)
            .attr("y1", 0)
            .attr("y2", svgHeight)
            .attr("stroke", "#ccc")
            .attr("stroke-dasharray", "2,2");

        // Formata o rótulo dependendo da escala
        const label = formatDynamicLabel(current, stepMs);

        // Se for sábado(6) ou domingo(0) e estamos em escala diária ou maior
        // => coloca em negrito
        let fontWeight = "normal";
        if (stepMs >= 86400000 && stepMs < 2592000000) {
            const dayIndex = current.getDay();
            if (dayIndex === 6 || dayIndex === 0) {
                fontWeight = "bold";
            }
        }

        // Coloca o label próximo à linha central
        svg.append("text")
            .attr("x", xPos + 3)
            .attr("y", (svgHeight / 2) - 5)
            .attr("fill", "#000")
            .style("font-size", "10px")
            .style("font-weight", fontWeight)
            .text(label);

        // Incrementa data
        current = new Date(current.getTime() + stepMs);
    }
}

// Função para formatar o rótulo dinâmico
function formatDynamicLabel(date, stepMs) {
    const dayOfWeek = date.toLocaleString("pt-BR", { weekday: "short" }); // ex: seg., ter., qua...
    const dayNum = date.getDate();
    const monthShort = date.toLocaleString("pt-BR", { month: "short" });  // jan, fev, etc.
    const year = date.getFullYear();

    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const seconds = String(date.getSeconds()).padStart(2, "0");

    if (stepMs < 60 * 1000) {
        // < 1 min => HH:MM:SS
        return `${hours}:${minutes}:${seconds}`;
    } else if (stepMs < 60 * 60 * 1000) {
        // < 1 hora => HH:MM
        return `${hours}:${minutes}`;
    } else if (stepMs < 24 * 60 * 60 * 1000) {
        // < 1 dia => exibe "HH:MM, Dia Mês"
        return `${hours}:${minutes}  ${dayNum} ${monthShort}`;
    } else if (stepMs < 30 * 24 * 60 * 60 * 1000) {
        // < ~1 mês => seg. 6, ter. 7, ...
        return `${dayOfWeek} ${dayNum}`;
    } else if (stepMs < 365 * 24 * 60 * 60 * 1000) {
        // < 1 ano => 6 jan
        return `${dayNum} ${monthShort}`;
    }
    // >= 1 ano => só exibe o ano
    return `${year}`;
}

// Função para adicionar o eixo superior semanal
function addWeekAxis(svg, startDate, endDate) {
    let current = new Date(startDate);
    let weekCount = 1;

    while (current < endDate) {
        const weekStart = new Date(current);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);

        if (weekEnd > endDate) {
            weekEnd.setTime(endDate.getTime());
        }

        const xStart = timeScale(weekStart);
        const xEnd = timeScale(weekEnd);

        svg.append("line")
            .attr("x1", xStart)
            .attr("x2", xStart)
            .attr("y1", 0)
            .attr("y2", svgHeight)
            .style("stroke", "#444")
            .style("stroke-width", 2);

        const startLabel = formatDateLabel(weekStart);
        const endLabel = formatDateLabel(weekEnd);
        const label = `Semana ${weekCount} (${startLabel} - ${endLabel})`;

        svg.append("text")
            .attr("x", xStart + 5)
            .attr("y", 20)
            .style("font-size", "11px")
            .style("fill", "#000")
            .text(label);

        current.setDate(current.getDate() + 7);
        weekCount++;
    }

    function formatDateLabel(d) {
        const day = d.getDate();
        const month = d.toLocaleString('pt-BR', { month: 'short' });
        const year = d.getFullYear();
        return `${day} ${month} ${year}`;
    }
}

// Função para adicionar linhas de grade extras
function addGridLines(svg, startDate, endDate) {
    const stepMs = getDynamicStep(startDate, endDate);
    let current = new Date(startDate);

    while (current <= endDate) {
        const xPos = timeScale(current);
        svg.append("line")
            .attr("x1", xPos)
            .attr("x2", xPos)
            .attr("y1", 0)
            .attr("y2", svgHeight)
            .attr("stroke", "#ccc")
            .attr("stroke-dasharray", "2,2");

        current = new Date(current.getTime() + stepMs);
    }
}

// Função para calcular o passo dinâmico
function getDynamicStep(startDate, endDate) {
    const diffMs = endDate - startDate;
    const diffSec = diffMs / 1000;

    if (diffSec < 60) {
        return 1000;             // 1s
    } else if (diffSec < 3600) {
        return 60 * 1000;        // 1 min
    } else if (diffSec < 86400) {
        return 3600 * 1000;      // 1h
    } else if (diffSec < 604800) {
        return 86400 * 1000;     // 1 dia
    } else if (diffSec < 2592000) {
        return 7 * 86400 * 1000; // 1 semana
    } else if (diffSec < 31536000) {
        return 30 * 86400 * 1000; // ~1 mês
    }
    // >= 1 ano
    return 365 * 86400 * 1000; // ou 30 dias, de modo aproximado
}

// Função para configurar a caixa de categorias
function setupCategoryBox(categories) {
    const categoryBox = document.getElementById("category-box");
    Object.entries(categories).forEach(([name, props]) => {
        const categoryItem = document.createElement("div");
        categoryItem.className = "category-item";
        categoryItem.innerHTML = `<span class="category-color" style="background:${props.color}"></span>${name}`;
        categoryItem.addEventListener("click", () => toggleCategory(name));
        categoryBox.appendChild(categoryItem);
    });

    function toggleCategory(name) {
        d3.selectAll(`.event-${name}`).classed("hidden", function () {
            return !d3.select(this).classed("hidden");
        });
    }
}

// Função para exibir a descrição do evento
function showDescription(event, e) {
    const eventDescription = document.getElementById("event-description");
    eventDescription.style.display = "block";
    eventDescription.style.left = `${e.pageX + 10}px`;
    eventDescription.style.top = `${e.pageY + 10}px`;
    eventDescription.textContent = event.description || "Nenhuma descrição disponível";
}

// Função para ocultar a descrição do evento
function hideDescription() {
    const eventDescription = document.getElementById("event-description");
    eventDescription.style.display = "none";
}

// Inicialização após o carregamento do DOM
document.addEventListener("DOMContentLoaded", function () {
    const timelineBtn = document.getElementById("timelineBtn");
    if (timelineBtn) {
        timelineBtn.addEventListener("click", function () {
            loadTimeline();
        });
    }
});

timeline.css
body {
    font-family: Arial, sans-serif;
}

#timeline {
    width: 90%;
    margin: auto;
    position: relative;
    background-color: #fff;
    /* A rolagem e height adicional são definidas no app.js para permitir grande área */
}

.era {
    fill-opacity: 0.3; /* Visual suave */
    stroke: #888;
    stroke-width: 1px;
    fill: rgba(173, 216, 230, 0.3); /* ex: azul claro pastel */
}

/* Eventos: retângulo + texto */
.event rect {
    stroke-width: 1px; /* Borda fina */
    rx: 5px;
    ry: 5px;
    fill-opacity: 0.9;
}

.event text {
    font-size: 12px;
    pointer-events: none;
    text-anchor: start;
}

/* Caixa de categorias */
.category-box {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid #ccc;
    padding: 10px;
    border-radius: 5px;
    z-index: 10;
    max-width: 250px;
    max-height: 150px; /* evita cobrir a timeline em telas menores */
    overflow-y: auto;
}

.category-item {
    margin-bottom: 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
}

.category-color {
    display: inline-block;
    width: 12px;
    height: 12px;
    margin-right: 5px;
    vertical-align: middle;
    border: 1px solid #000;
}

.category-item:hover {
    background: rgba(200, 200, 200, 0.5);
}

/* Tooltip para descrição do evento */
.event-description {
    display: none;
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid #ccc;
    padding: 5px;
    border-radius: 3px;
    pointer-events: none;
    font-size: 12px;
    z-index: 20;
    max-width: 200px;
    word-wrap: break-word;
}

/* Linhas de grade */
.grid-line {
    stroke: #ccc;
    stroke-dasharray: 2,2;
}

/* Texto das linhas de grid */
.grid-text {
    font-size: 10px;
    fill: #000;
    text-anchor: middle;
}

/* Eixo principal */
.x-axis {
    font-size: 10px;
    fill: #000;
}

/* Datas centrais */
.date-label {
    font-size: 10px;
    fill: #000;
    text-anchor: middle;
}

/* Eixo superior das semanas */
.x-axis-top {
    font-size: 10px;
    fill: #000;
}

/* Camada de eventos, isolada */
.event-layer {
    isolation: isolate;
}

mapa.html
<!DOCTYPE html>
<html>
<head>
    
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    
        <script>
            L_NO_TOUCH = false;
            L_DISABLE_3D = false;
        </script>
    
    <style>html, body {width: 100%;height: 100%;margin: 0;padding: 0;}</style>
    <style>#map {position:absolute;top:0;bottom:0;right:0;left:0;}</style>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css"/>
    
            <meta name="viewport" content="width=device-width,
                initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
            <style>
                #map_c4a26b798782513765f4ebd39b4f0de8 {
                    position: relative;
                    width: 100.0%;
                    height: 100.0%;
                    left: 0.0%;
                    top: 0.0%;
                }
                .leaflet-container { font-size: 1rem; }
            </style>
        
</head>
<body>
    
    
            <div class="folium-map" id="map_c4a26b798782513765f4ebd39b4f0de8" ></div>
        
</body>
<script>
    
    
            var map_c4a26b798782513765f4ebd39b4f0de8 = L.map(
                "map_c4a26b798782513765f4ebd39b4f0de8",
                {
                    center: [-15.0, -50.0],
                    crs: L.CRS.EPSG3857,
                    ...{
  "zoom": 4,
  "zoomControl": true,
  "preferCanvas": false,
}

                }
            );

            

        
    
            var tile_layer_78f5fe17c39d3e343f077b703fc98f09 = L.tileLayer(
                "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
                {
  "minZoom": 0,
  "maxZoom": 19,
  "maxNativeZoom": 19,
  "noWrap": false,
  "attribution": "\u0026copy; \u003ca href=\"https://www.openstreetmap.org/copyright\"\u003eOpenStreetMap\u003c/a\u003e contributors",
  "subdomains": "abc",
  "detectRetina": false,
  "tms": false,
  "opacity": 1,
}

            );
        
    
            tile_layer_78f5fe17c39d3e343f077b703fc98f09.addTo(map_c4a26b798782513765f4ebd39b4f0de8);
        
    
            var marker_96f599058996cb206242b790db312f41 = L.marker(
                [-10.3333333, -53.2],
                {
}
            ).addTo(map_c4a26b798782513765f4ebd39b4f0de8);
        
    
            var icon_cecc7b2f356af0e56816aae52469d5f5 = L.AwesomeMarkers.icon(
                {
  "markerColor": "blue",
  "iconColor": "white",
  "icon": "info-sign",
  "prefix": "glyphicon",
  "extraClasses": "fa-rotate-0",
}
            );
            marker_96f599058996cb206242b790db312f41.setIcon(icon_cecc7b2f356af0e56816aae52469d5f5);
        
    
        var popup_f6da78bf43ac9dd24c013e5467d8aa06 = L.popup({
  "maxWidth": "100%",
});

        
            
                var html_315f91993c7854067f0ad341c78b1ae9 = $(`<div id="html_315f91993c7854067f0ad341c78b1ae9" style="width: 100.0%; height: 100.0%;">Entidade: Brasil<br>Tipo: localização<br>Local Esperado: None<br>Sentimento: 0.00</div>`)[0];
                popup_f6da78bf43ac9dd24c013e5467d8aa06.setContent(html_315f91993c7854067f0ad341c78b1ae9);
            
        

        marker_96f599058996cb206242b790db312f41.bindPopup(popup_f6da78bf43ac9dd24c013e5467d8aa06)
        ;

        
    
    
            marker_96f599058996cb206242b790db312f41.bindTooltip(
                `<div>
                     Brasil - localização
                 </div>`,
                {
  "sticky": true,
}
            );
        
    
            var marker_c210a52244c9b2719614cca51d0abfd9 = L.marker(
                [-15.79899835, -47.860765675844334],
                {
}
            ).addTo(map_c4a26b798782513765f4ebd39b4f0de8);
        
    
            var icon_e09eb1b8b4e7699e2c864c73cb03a714 = L.AwesomeMarkers.icon(
                {
  "markerColor": "blue",
  "iconColor": "white",
  "icon": "info-sign",
  "prefix": "glyphicon",
  "extraClasses": "fa-rotate-0",
}
            );
            marker_c210a52244c9b2719614cca51d0abfd9.setIcon(icon_e09eb1b8b4e7699e2c864c73cb03a714);
        
    
        var popup_7c9bb336e17ebd8454551d2e6dd3ae08 = L.popup({
  "maxWidth": "100%",
});

        
            
                var html_52cc269da72cfced991faccbc133ca9b = $(`<div id="html_52cc269da72cfced991faccbc133ca9b" style="width: 100.0%; height: 100.0%;">Entidade: Palácio do Planalto<br>Tipo: localização<br>Local Esperado: Brasília<br>Sentimento: 0.00</div>`)[0];
                popup_7c9bb336e17ebd8454551d2e6dd3ae08.setContent(html_52cc269da72cfced991faccbc133ca9b);
            
        

        marker_c210a52244c9b2719614cca51d0abfd9.bindPopup(popup_7c9bb336e17ebd8454551d2e6dd3ae08)
        ;

        
    
    
            marker_c210a52244c9b2719614cca51d0abfd9.bindTooltip(
                `<div>
                     Palácio do Planalto - localização
                 </div>`,
                {
  "sticky": true,
}
            );
        
    
            var marker_fc69f2faa0b7d2f1f5c55b0a8c631ab6 = L.marker(
                [-10.3333333, -53.2],
                {
}
            ).addTo(map_c4a26b798782513765f4ebd39b4f0de8);
        
    
            var icon_311d6e7047a185e2286fa0e9b41859b4 = L.AwesomeMarkers.icon(
                {
  "markerColor": "blue",
  "iconColor": "white",
  "icon": "info-sign",
  "prefix": "glyphicon",
  "extraClasses": "fa-rotate-0",
}
            );
            marker_fc69f2faa0b7d2f1f5c55b0a8c631ab6.setIcon(icon_311d6e7047a185e2286fa0e9b41859b4);
        
    
        var popup_8a40ac149d77145f91057d95cec6da52 = L.popup({
  "maxWidth": "100%",
});

        
            
                var html_12c96a15c60a903770acd384f6fd2db7 = $(`<div id="html_12c96a15c60a903770acd384f6fd2db7" style="width: 100.0%; height: 100.0%;">Entidade: Brasil<br>Tipo: localização<br>Local Esperado: None<br>Sentimento: 0.00</div>`)[0];
                popup_8a40ac149d77145f91057d95cec6da52.setContent(html_12c96a15c60a903770acd384f6fd2db7);
            
        

        marker_fc69f2faa0b7d2f1f5c55b0a8c631ab6.bindPopup(popup_8a40ac149d77145f91057d95cec6da52)
        ;

        
    
    
            marker_fc69f2faa0b7d2f1f5c55b0a8c631ab6.bindTooltip(
                `<div>
                     Brasil - localização
                 </div>`,
                {
  "sticky": true,
}
            );
        
    
            var marker_4422bf73e8632ed666b45e7d143e52a8 = L.marker(
                [-10.3333333, -53.2],
                {
}
            ).addTo(map_c4a26b798782513765f4ebd39b4f0de8);
        
    
            var icon_de47b3dea86034eeda44ce0d9ce462d4 = L.AwesomeMarkers.icon(
                {
  "markerColor": "blue",
  "iconColor": "white",
  "icon": "info-sign",
  "prefix": "glyphicon",
  "extraClasses": "fa-rotate-0",
}
            );
            marker_4422bf73e8632ed666b45e7d143e52a8.setIcon(icon_de47b3dea86034eeda44ce0d9ce462d4);
        
    
        var popup_5ba10e24920ad42d922c27fd062ee565 = L.popup({
  "maxWidth": "100%",
});

        
            
                var html_caab2213a16ea3654f078cdc5849762f = $(`<div id="html_caab2213a16ea3654f078cdc5849762f" style="width: 100.0%; height: 100.0%;">Entidade: Brasil<br>Tipo: localização<br>Local Esperado: None<br>Sentimento: 0.00</div>`)[0];
                popup_5ba10e24920ad42d922c27fd062ee565.setContent(html_caab2213a16ea3654f078cdc5849762f);
            
        

        marker_4422bf73e8632ed666b45e7d143e52a8.bindPopup(popup_5ba10e24920ad42d922c27fd062ee565)
        ;

        
    
    
            marker_4422bf73e8632ed666b45e7d143e52a8.bindTooltip(
                `<div>
                     Brasil - localização
                 </div>`,
                {
  "sticky": true,
}
            );
        
    
            var marker_4db8a050783ad7f6a1ff71add83d5f67 = L.marker(
                [-10.3333333, -53.2],
                {
}
            ).addTo(map_c4a26b798782513765f4ebd39b4f0de8);
        
    
            var icon_07928aa069628c745c3f5b43b4a30496 = L.AwesomeMarkers.icon(
                {
  "markerColor": "blue",
  "iconColor": "white",
  "icon": "info-sign",
  "prefix": "glyphicon",
  "extraClasses": "fa-rotate-0",
}
            );
            marker_4db8a050783ad7f6a1ff71add83d5f67.setIcon(icon_07928aa069628c745c3f5b43b4a30496);
        
    
        var popup_e14ccdce4df3b8ec9636253dcb40cc93 = L.popup({
  "maxWidth": "100%",
});

        
            
                var html_701b8de274a074d609f965550981f4e4 = $(`<div id="html_701b8de274a074d609f965550981f4e4" style="width: 100.0%; height: 100.0%;">Entidade: Brasil<br>Tipo: localização<br>Local Esperado: None<br>Sentimento: 0.00</div>`)[0];
                popup_e14ccdce4df3b8ec9636253dcb40cc93.setContent(html_701b8de274a074d609f965550981f4e4);
            
        

        marker_4db8a050783ad7f6a1ff71add83d5f67.bindPopup(popup_e14ccdce4df3b8ec9636253dcb40cc93)
        ;

        
    
    
            marker_4db8a050783ad7f6a1ff71add83d5f67.bindTooltip(
                `<div>
                     Brasil - localização
                 </div>`,
                {
  "sticky": true,
}
            );
        
    
            var marker_4919f0762d7d3da7be3e80cbd872e799 = L.marker(
                [-10.3333333, -53.2],
                {
}
            ).addTo(map_c4a26b798782513765f4ebd39b4f0de8);
        
    
            var icon_45f6f4297b53d97dc26c8182c776e5c2 = L.AwesomeMarkers.icon(
                {
  "markerColor": "blue",
  "iconColor": "white",
  "icon": "info-sign",
  "prefix": "glyphicon",
  "extraClasses": "fa-rotate-0",
}
            );
            marker_4919f0762d7d3da7be3e80cbd872e799.setIcon(icon_45f6f4297b53d97dc26c8182c776e5c2);
        
    
        var popup_f609d5797407bf792ec8a2eb7ae455ca = L.popup({
  "maxWidth": "100%",
});

        
            
                var html_1b7d83e67887377c59585e4f3faf2540 = $(`<div id="html_1b7d83e67887377c59585e4f3faf2540" style="width: 100.0%; height: 100.0%;">Entidade: Brasil<br>Tipo: localização<br>Local Esperado: None<br>Sentimento: 0.00</div>`)[0];
                popup_f609d5797407bf792ec8a2eb7ae455ca.setContent(html_1b7d83e67887377c59585e4f3faf2540);
            
        

        marker_4919f0762d7d3da7be3e80cbd872e799.bindPopup(popup_f609d5797407bf792ec8a2eb7ae455ca)
        ;

        
    
    
            marker_4919f0762d7d3da7be3e80cbd872e799.bindTooltip(
                `<div>
                     Brasil - localização
                 </div>`,
                {
  "sticky": true,
}
            );
        
</script>
</html>

