Considere uma aplicação django a qual precisa ativar microsserviços flask em cada uma das ativações de uma instância, e deverá entregar o conteúdo deste para a visualização; este microsserviço flask rodará dentro de um container docker, ao mesmo tempo, a aplicação django já roda num container docker e é servida via ngix e uwsgi, e outros containers flask deverão ser iniciados na criação/destruição/reativação de cada instância flask e serão servidos pelo django; no contexto atual o django espera em localhost:5000 o conteúdo do container flask; cada container flask deve ter uma identificação única somando o nome dadopelo usuário e uma string aleatória única; partindo daqui, depure e indique onde buscar mais informações sobre esta integração.

forms.py
from django import forms
from .models import FlaskInstance

class FlaskInstanceForm(forms.ModelForm):
    class Meta:
        model = FlaskInstance
        fields = ['name']  # Campos editáveis pelo usuário

views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import FlaskInstance
from .forms import FlaskInstanceForm
import docker

def landing_page(request):
    return render(request, 'landing_page.html')

@login_required
def instance_list(request):
    instances = FlaskInstance.objects.filter(user=request.user)
    return render(request, 'blog/instance_list.html', {'instances': instances})

@login_required
def create_instance(request):
    if request.method == 'POST':
        form = FlaskInstanceForm(request.POST)
        if form.is_valid():
            instance = form.save(commit=False)
            instance.user = request.user
            instance.save()
            messages.success(request, "Instância criada com sucesso!")
            return redirect('instance_list')
    else:
        form = FlaskInstanceForm()
    return render(request, 'blog/instance_form.html', {'form': form})

@login_required
def start_instance(request, pk):
    try:
        client = docker.from_env()
        instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
        if not instance.container_id:
            container = client.containers.run(
                'sua-imagem-flask',  # Nome da imagem Docker da aplicação Flask
                detach=True,  # Executa o container em segundo plano
                name=f"flask-instance-{instance.pk}",  # Nome único para o container
                ports={'5000/tcp': 5000}  # Expõe a porta 5000
            )
            instance.container_id = container.id
            instance.save()
            messages.success(request, "Instância iniciada com sucesso!")
        else:
            messages.warning(request, "A instância já está em execução.")
    except docker.errors.DockerException as e:
        messages.error(request, f"Erro ao iniciar a instância: {e}")
    return redirect('instance_list')

@login_required
def stop_instance(request, pk):
    try:
        client = docker.from_env()
        instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
        if instance.container_id:
            container = client.containers.get(instance.container_id)
            container.stop()
            instance.container_id = None
            instance.save()
            messages.success(request, "Instância parada com sucesso!")
        else:
            messages.warning(request, "A instância já está parada.")
    except docker.errors.DockerException as e:
        messages.error(request, f"Erro ao parar a instância: {e}")
    return redirect('instance_list')

@login_required
def view_instance(request, pk):
    instance = get_object_or_404(FlaskInstance, pk=pk, user=request.user)
    return render(request, 'blog/instance_view.html', {'instance': instance})

models.py
from django.db import models
from django.contrib.auth.models import User

class FlaskInstance(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)  # Usuário que criou a instância
    container_id = models.CharField(max_length=100, blank=True, null=True)  # ID do container Docker
    name = models.CharField(max_length=200)  # Nome da instância
    created_at = models.DateTimeField(auto_now_add=True)  # Data de criação
    updated_at = models.DateTimeField(auto_now=True)  # Data de atualização

    def __str__(self):
        return self.name


table inet filter {
    chain input {
        type filter hook input priority filter; policy drop;
        
        iif "lo" accept
        ct state established,related accept
        ip protocol icmp accept

        # Serviços WAN permitidos na br0
        iifname "br0" tcp dport 22 accept            
        iifname "br0" udp dport 1194 accept          
        iifname "br0" udp dport 4747 accept          
        iifname "br0" tcp dport 1714-1768 accept     
        iifname "br0" udp dport 1714-1768 accept     
        iifname "br0" udp dport 9 accept            
        iifname "br0" tcp dport 24800 accept        

        # HTTP e HTTPS no host
        iifname "br0" tcp dport { 80, 443 } accept

        # Permitir tráfego para VM em 192.168.0.14 (incluindo 8000)
        iifname "br0" ip daddr 192.168.0.14 tcp dport { 8000, 8080, 8443 } accept

        # Rede interna br1 - abrindo portas específicas (SSH, DNS, DHCP, NFS)
        # (descomente e adicione as portas de NFS conforme necessidade)
        iifname "br1" udp dport { 53, 67, 111, 2049, 20048 } accept
        iifname "br1" tcp dport { 22, 53, 111, 2049, 20048 } accept
    }

    chain forward {
        type filter hook forward priority filter; policy accept;

        iifname "br0" oifname "enp7s0" accept
        oifname "br0" iifname "enp7s0" accept

        # Comunicação interna (mantido comentado, se não desejar liberar tudo)
        iifname "br1" accept
        oifname "br1" accept
        iifname "br0" oifname "br1" accept
        iifname "br1" oifname "br0" accept

        # Permitir tráfego para a VM (HTTP e HTTPS) + porta 8000
        iifname "br0" ip daddr 192.168.0.14 tcp dport { 8000, 8080, 8443 } accept
        iifname "br1" ip saddr 192.168.0.14 tcp dport { 8000, 8080, 8443 } accept
    }

    chain output {
        type filter hook output priority filter; policy accept;

        # Permitir saída para tráfego essencial na br1 (conforme necessidade)
        oifname "br1" ip daddr 192.168.0.14 tcp dport { 8080, 8443 } accept
    }
}









rm /usr/local/bin/update_nftables_docker.py ; nano /usr/local/bin/update_nftables_docker.py ; chmod +x /usr/local/bin/update_nftables_docker.py ; nft flush ruleset ; rm /etc/nftables.conf ; nano /etc/nftables.conf ; nft -f /etc/nftables.conf ; systemctl restart nftables ; nft list ruleset ; systemctl status nftables ; docker system prune -a ; docker network create --driver=bridge --subnet=172.18.0.0/16 app_network ; docker network inspect app_network ; docker network list ; ip addr show ; cat /usr/local/bin/update_nftables_docker.py ; /usr/local/bin/update_nftables_docker.py ; nft list ruleset ; cat /etc/nftables.conf ; docker-compose up --build  
